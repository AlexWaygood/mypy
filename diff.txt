diff --git a/.pre-commit-config.yaml b/.pre-commit-config.yaml
index a74edd12f..0a0685900 100644
--- a/.pre-commit-config.yaml
+++ b/.pre-commit-config.yaml
@@ -1,3 +1,4 @@
+exclude: '^mypyc/external/'
 repos:
   - repo: https://github.com/pre-commit/pre-commit-hooks
     rev: v4.4.0  # must match test-requirements.txt
diff --git a/mypyc/test-data/driver/driver.py b/mypyc/test-data/driver/driver.py
index 6717f402f..9f26658d2 100644
--- a/mypyc/test-data/driver/driver.py
+++ b/mypyc/test-data/driver/driver.py
@@ -13,7 +13,7 @@ import native
 failures = []
 
 for name in dir(native):
-    if name.startswith('test_'):
+    if name.startswith("test_"):
         test_func = getattr(native, name)
         try:
             test_func()
@@ -25,7 +25,7 @@ if failures:
     import re
 
     def extract_line(tb):
-        formatted = '\n'.join(format_tb(tb))
+        formatted = "\n".join(format_tb(tb))
         m = re.search('File "(native|driver).py", line ([0-9]+), in (test_|<module>)', formatted)
         if m is None:
             return "0"
diff --git a/mypyc/test-data/fixtures/ir.py b/mypyc/test-data/fixtures/ir.py
index 0b081b079..3c8487dfd 100644
--- a/mypyc/test-data/fixtures/ir.py
+++ b/mypyc/test-data/fixtures/ir.py
@@ -3,365 +3,915 @@
 
 import _typeshed
 from typing import (
-    TypeVar, Generic, List, Iterator, Iterable, Dict, Optional, Tuple, Any, Set,
-    overload, Mapping, Union, Callable, Sequence, FrozenSet, Protocol
+    TypeVar,
+    Generic,
+    List,
+    Iterator,
+    Iterable,
+    Dict,
+    Optional,
+    Tuple,
+    Any,
+    Set,
+    overload,
+    Mapping,
+    Union,
+    Callable,
+    Sequence,
+    FrozenSet,
+    Protocol,
 )
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-T_contra = TypeVar('T_contra', contravariant=True)
-S = TypeVar('S')
-K = TypeVar('K') # for keys in mapping
-V = TypeVar('V') # for values in mapping
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+T_contra = TypeVar("T_contra", contravariant=True)
+S = TypeVar("S")
+K = TypeVar("K")  # for keys in mapping
+V = TypeVar("V")  # for values in mapping
+
 
 class __SupportsAbs(Protocol[T_co]):
-    def __abs__(self) -> T_co: pass
+    def __abs__(self) -> T_co:
+        pass
+
 
 class __SupportsDivMod(Protocol[T_contra, T_co]):
-    def __divmod__(self, other: T_contra) -> T_co: ...
+    def __divmod__(self, other: T_contra) -> T_co:
+        ...
+
 
 class __SupportsRDivMod(Protocol[T_contra, T_co]):
-    def __rdivmod__(self, other: T_contra) -> T_co: ...
+    def __rdivmod__(self, other: T_contra) -> T_co:
+        ...
+
 
 _M = TypeVar("_M", contravariant=True)
 
+
 class __SupportsPow2(Protocol[T_contra, T_co]):
-    def __pow__(self, other: T_contra) -> T_co: ...
+    def __pow__(self, other: T_contra) -> T_co:
+        ...
+
 
 class __SupportsPow3NoneOnly(Protocol[T_contra, T_co]):
-    def __pow__(self, other: T_contra, modulo: None = ...) -> T_co: ...
+    def __pow__(self, other: T_contra, modulo: None = ...) -> T_co:
+        ...
+
 
 class __SupportsPow3(Protocol[T_contra, _M, T_co]):
-    def __pow__(self, other: T_contra, modulo: _M) -> T_co: ...
+    def __pow__(self, other: T_contra, modulo: _M) -> T_co:
+        ...
+
 
 __SupportsSomeKindOfPow = Union[
     __SupportsPow2[Any, Any], __SupportsPow3NoneOnly[Any, Any] | __SupportsPow3[Any, Any, Any]
 ]
 
+
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, x: object) -> bool: pass
-    def __ne__(self, x: object) -> bool: pass
+    def __init__(self) -> None:
+        pass
+
+    def __eq__(self, x: object) -> bool:
+        pass
+
+    def __ne__(self, x: object) -> bool:
+        pass
+
 
 class type:
-    def __init__(self, o: object) -> None: ...
-    __name__ : str
+    def __init__(self, o: object) -> None:
+        ...
+
+    __name__: str
     __annotations__: Dict[str, Any]
 
-class ellipsis: pass
+
+class ellipsis:
+    pass
+
 
 # Primitive types are special in generated code.
 
+
 class int:
     @overload
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
     @overload
-    def __init__(self, x: object, base: int = 10) -> None: pass
-    def __add__(self, n: int) -> int: pass
-    def __sub__(self, n: int) -> int: pass
-    def __mul__(self, n: int) -> int: pass
-    def __pow__(self, n: int, modulo: Optional[int] = None) -> int: pass
-    def __floordiv__(self, x: int) -> int: pass
-    def __truediv__(self, x: float) -> float: pass
-    def __mod__(self, x: int) -> int: pass
-    def __divmod__(self, x: float) -> Tuple[float, float]: pass
-    def __neg__(self) -> int: pass
-    def __pos__(self) -> int: pass
-    def __abs__(self) -> int: pass
-    def __invert__(self) -> int: pass
-    def __and__(self, n: int) -> int: pass
-    def __or__(self, n: int) -> int: pass
-    def __xor__(self, n: int) -> int: pass
-    def __lshift__(self, x: int) -> int: pass
-    def __rshift__(self, x: int) -> int: pass
-    def __eq__(self, n: object) -> bool: pass
-    def __ne__(self, n: object) -> bool: pass
-    def __lt__(self, n: int) -> bool: pass
-    def __gt__(self, n: int) -> bool: pass
-    def __le__(self, n: int) -> bool: pass
-    def __ge__(self, n: int) -> bool: pass
+    def __init__(self, x: object, base: int = 10) -> None:
+        pass
+
+    def __add__(self, n: int) -> int:
+        pass
+
+    def __sub__(self, n: int) -> int:
+        pass
+
+    def __mul__(self, n: int) -> int:
+        pass
+
+    def __pow__(self, n: int, modulo: Optional[int] = None) -> int:
+        pass
+
+    def __floordiv__(self, x: int) -> int:
+        pass
+
+    def __truediv__(self, x: float) -> float:
+        pass
+
+    def __mod__(self, x: int) -> int:
+        pass
+
+    def __divmod__(self, x: float) -> Tuple[float, float]:
+        pass
+
+    def __neg__(self) -> int:
+        pass
+
+    def __pos__(self) -> int:
+        pass
+
+    def __abs__(self) -> int:
+        pass
+
+    def __invert__(self) -> int:
+        pass
+
+    def __and__(self, n: int) -> int:
+        pass
+
+    def __or__(self, n: int) -> int:
+        pass
+
+    def __xor__(self, n: int) -> int:
+        pass
+
+    def __lshift__(self, x: int) -> int:
+        pass
+
+    def __rshift__(self, x: int) -> int:
+        pass
+
+    def __eq__(self, n: object) -> bool:
+        pass
+
+    def __ne__(self, n: object) -> bool:
+        pass
+
+    def __lt__(self, n: int) -> bool:
+        pass
+
+    def __gt__(self, n: int) -> bool:
+        pass
+
+    def __le__(self, n: int) -> bool:
+        pass
+
+    def __ge__(self, n: int) -> bool:
+        pass
+
 
 class str:
     @overload
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
     @overload
-    def __init__(self, x: object) -> None: pass
-    def __add__(self, x: str) -> str: pass
-    def __eq__(self, x: object) -> bool: pass
-    def __ne__(self, x: object) -> bool: pass
-    def __lt__(self, x: str) -> bool: ...
-    def __le__(self, x: str) -> bool: ...
-    def __gt__(self, x: str) -> bool: ...
-    def __ge__(self, x: str) -> bool: ...
+    def __init__(self, x: object) -> None:
+        pass
+
+    def __add__(self, x: str) -> str:
+        pass
+
+    def __eq__(self, x: object) -> bool:
+        pass
+
+    def __ne__(self, x: object) -> bool:
+        pass
+
+    def __lt__(self, x: str) -> bool:
+        ...
+
+    def __le__(self, x: str) -> bool:
+        ...
+
+    def __gt__(self, x: str) -> bool:
+        ...
+
+    def __ge__(self, x: str) -> bool:
+        ...
+
     @overload
-    def __getitem__(self, i: int) -> str: pass
+    def __getitem__(self, i: int) -> str:
+        pass
+
     @overload
-    def __getitem__(self, i: slice) -> str: pass
-    def __contains__(self, item: str) -> bool: pass
-    def __iter__(self) -> Iterator[str]: ...
-    def split(self, sep: Optional[str] = None, max: Optional[int] = None) -> List[str]: pass
-    def strip (self, item: str) -> str: pass
-    def join(self, x: Iterable[str]) -> str: pass
-    def format(self, *args: Any, **kwargs: Any) -> str: ...
-    def upper(self) -> str: ...
-    def startswith(self, x: str, start: int=..., end: int=...) -> bool: ...
-    def endswith(self, x: str, start: int=..., end: int=...) -> bool: ...
-    def replace(self, old: str, new: str, maxcount: int=...) -> str: ...
-    def encode(self, x: str=..., y: str=...) -> bytes: ...
+    def __getitem__(self, i: slice) -> str:
+        pass
+
+    def __contains__(self, item: str) -> bool:
+        pass
+
+    def __iter__(self) -> Iterator[str]:
+        ...
+
+    def split(self, sep: Optional[str] = None, max: Optional[int] = None) -> List[str]:
+        pass
+
+    def strip(self, item: str) -> str:
+        pass
+
+    def join(self, x: Iterable[str]) -> str:
+        pass
+
+    def format(self, *args: Any, **kwargs: Any) -> str:
+        ...
+
+    def upper(self) -> str:
+        ...
+
+    def startswith(self, x: str, start: int = ..., end: int = ...) -> bool:
+        ...
+
+    def endswith(self, x: str, start: int = ..., end: int = ...) -> bool:
+        ...
+
+    def replace(self, old: str, new: str, maxcount: int = ...) -> str:
+        ...
+
+    def encode(self, x: str = ..., y: str = ...) -> bytes:
+        ...
+
 
 class float:
-    def __init__(self, x: object) -> None: pass
-    def __add__(self, n: float) -> float: pass
-    def __radd__(self, n: float) -> float: pass
-    def __sub__(self, n: float) -> float: pass
-    def __rsub__(self, n: float) -> float: pass
-    def __mul__(self, n: float) -> float: pass
-    def __truediv__(self, n: float) -> float: pass
-    def __floordiv__(self, n: float) -> float: pass
-    def __mod__(self, n: float) -> float: pass
-    def __pow__(self, n: float) -> float: pass
-    def __neg__(self) -> float: pass
-    def __pos__(self) -> float: pass
-    def __abs__(self) -> float: pass
-    def __invert__(self) -> float: pass
-    def __eq__(self, x: object) -> bool: pass
-    def __ne__(self, x: object) -> bool: pass
-    def __lt__(self, x: float) -> bool: ...
-    def __le__(self, x: float) -> bool: ...
-    def __gt__(self, x: float) -> bool: ...
-    def __ge__(self, x: float) -> bool: ...
+    def __init__(self, x: object) -> None:
+        pass
+
+    def __add__(self, n: float) -> float:
+        pass
+
+    def __radd__(self, n: float) -> float:
+        pass
+
+    def __sub__(self, n: float) -> float:
+        pass
+
+    def __rsub__(self, n: float) -> float:
+        pass
+
+    def __mul__(self, n: float) -> float:
+        pass
+
+    def __truediv__(self, n: float) -> float:
+        pass
+
+    def __floordiv__(self, n: float) -> float:
+        pass
+
+    def __mod__(self, n: float) -> float:
+        pass
+
+    def __pow__(self, n: float) -> float:
+        pass
+
+    def __neg__(self) -> float:
+        pass
+
+    def __pos__(self) -> float:
+        pass
+
+    def __abs__(self) -> float:
+        pass
+
+    def __invert__(self) -> float:
+        pass
+
+    def __eq__(self, x: object) -> bool:
+        pass
+
+    def __ne__(self, x: object) -> bool:
+        pass
+
+    def __lt__(self, x: float) -> bool:
+        ...
+
+    def __le__(self, x: float) -> bool:
+        ...
+
+    def __gt__(self, x: float) -> bool:
+        ...
+
+    def __ge__(self, x: float) -> bool:
+        ...
+
 
 class complex:
-    def __init__(self, x: object, y: object = None) -> None: pass
-    def __add__(self, n: complex) -> complex: pass
-    def __sub__(self, n: complex) -> complex: pass
-    def __mul__(self, n: complex) -> complex: pass
-    def __truediv__(self, n: complex) -> complex: pass
-    def __neg__(self) -> complex: pass
+    def __init__(self, x: object, y: object = None) -> None:
+        pass
+
+    def __add__(self, n: complex) -> complex:
+        pass
+
+    def __sub__(self, n: complex) -> complex:
+        pass
+
+    def __mul__(self, n: complex) -> complex:
+        pass
+
+    def __truediv__(self, n: complex) -> complex:
+        pass
+
+    def __neg__(self) -> complex:
+        pass
+
 
 class bytes:
     @overload
-    def __init__(self) -> None: ...
+    def __init__(self) -> None:
+        ...
+
     @overload
-    def __init__(self, x: object) -> None: ...
-    def __add__(self, x: bytes) -> bytes: ...
-    def __eq__(self, x: object) -> bool: ...
-    def __ne__(self, x: object) -> bool: ...
+    def __init__(self, x: object) -> None:
+        ...
+
+    def __add__(self, x: bytes) -> bytes:
+        ...
+
+    def __eq__(self, x: object) -> bool:
+        ...
+
+    def __ne__(self, x: object) -> bool:
+        ...
+
     @overload
-    def __getitem__(self, i: int) -> int: ...
+    def __getitem__(self, i: int) -> int:
+        ...
+
     @overload
-    def __getitem__(self, i: slice) -> bytes: ...
-    def join(self, x: Iterable[object]) -> bytes: ...
-    def decode(self, x: str=..., y: str=...) -> str: ...
+    def __getitem__(self, i: slice) -> bytes:
+        ...
+
+    def join(self, x: Iterable[object]) -> bytes:
+        ...
+
+    def decode(self, x: str = ..., y: str = ...) -> str:
+        ...
+
 
 class bytearray:
     @overload
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
     @overload
-    def __init__(self, x: object) -> None: pass
+    def __init__(self, x: object) -> None:
+        pass
+
     @overload
-    def __init__(self, string: str, encoding: str, err: str = ...) -> None: pass
-    def __add__(self, s: bytes) -> bytearray: ...
-    def __setitem__(self, i: int, o: int) -> None: ...
-    def __getitem__(self, i: int) -> int: ...
-    def decode(self, x: str = ..., y: str = ...) -> str: ...
+    def __init__(self, string: str, encoding: str, err: str = ...) -> None:
+        pass
+
+    def __add__(self, s: bytes) -> bytearray:
+        ...
+
+    def __setitem__(self, i: int, o: int) -> None:
+        ...
+
+    def __getitem__(self, i: int) -> int:
+        ...
+
+    def decode(self, x: str = ..., y: str = ...) -> str:
+        ...
+
 
 class bool(int):
-    def __init__(self, o: object = ...) -> None: ...
+    def __init__(self, o: object = ...) -> None:
+        ...
+
     @overload
-    def __and__(self, n: bool) -> bool: ...
+    def __and__(self, n: bool) -> bool:
+        ...
+
     @overload
-    def __and__(self, n: int) -> int: ...
+    def __and__(self, n: int) -> int:
+        ...
+
     @overload
-    def __or__(self, n: bool) -> bool: ...
+    def __or__(self, n: bool) -> bool:
+        ...
+
     @overload
-    def __or__(self, n: int) -> int: ...
+    def __or__(self, n: int) -> int:
+        ...
+
     @overload
-    def __xor__(self, n: bool) -> bool: ...
+    def __xor__(self, n: bool) -> bool:
+        ...
+
     @overload
-    def __xor__(self, n: int) -> int: ...
+    def __xor__(self, n: int) -> int:
+        ...
+
 
 class tuple(Generic[T_co], Sequence[T_co], Iterable[T_co]):
-    def __init__(self, i: Iterable[T_co]) -> None: pass
+    def __init__(self, i: Iterable[T_co]) -> None:
+        pass
+
     @overload
-    def __getitem__(self, i: int) -> T_co: pass
+    def __getitem__(self, i: int) -> T_co:
+        pass
+
     @overload
-    def __getitem__(self, i: slice) -> Tuple[T_co, ...]: pass
-    def __len__(self) -> int: pass
-    def __iter__(self) -> Iterator[T_co]: ...
-    def __contains__(self, item: object) -> int: ...
+    def __getitem__(self, i: slice) -> Tuple[T_co, ...]:
+        pass
+
+    def __len__(self) -> int:
+        pass
+
+    def __iter__(self) -> Iterator[T_co]:
+        ...
+
+    def __contains__(self, item: object) -> int:
+        ...
+
+
+class function:
+    pass
 
-class function: pass
 
 class list(Generic[T], Sequence[T], Iterable[T]):
-    def __init__(self, i: Optional[Iterable[T]] = None) -> None: pass
+    def __init__(self, i: Optional[Iterable[T]] = None) -> None:
+        pass
+
     @overload
-    def __getitem__(self, i: int) -> T: ...
+    def __getitem__(self, i: int) -> T:
+        ...
+
     @overload
-    def __getitem__(self, s: slice) -> List[T]: ...
-    def __setitem__(self, i: int, o: T) -> None: pass
-    def __delitem__(self, i: int) -> None: pass
-    def __mul__(self, i: int) -> List[T]: pass
-    def __rmul__(self, i: int) -> List[T]: pass
-    def __iter__(self) -> Iterator[T]: pass
-    def __len__(self) -> int: pass
-    def __contains__(self, item: object) -> int: ...
-    def __add__(self, x: List[T]) -> List[T]: ...
-    def append(self, x: T) -> None: pass
-    def pop(self, i: int = -1) -> T: pass
-    def count(self, T) -> int: pass
-    def extend(self, l: Iterable[T]) -> None: pass
-    def insert(self, i: int, x: T) -> None: pass
-    def sort(self) -> None: pass
-    def reverse(self) -> None: pass
-    def remove(self, o: T) -> None: pass
-    def index(self, o: T) -> int: pass
+    def __getitem__(self, s: slice) -> List[T]:
+        ...
+
+    def __setitem__(self, i: int, o: T) -> None:
+        pass
+
+    def __delitem__(self, i: int) -> None:
+        pass
+
+    def __mul__(self, i: int) -> List[T]:
+        pass
+
+    def __rmul__(self, i: int) -> List[T]:
+        pass
+
+    def __iter__(self) -> Iterator[T]:
+        pass
+
+    def __len__(self) -> int:
+        pass
+
+    def __contains__(self, item: object) -> int:
+        ...
+
+    def __add__(self, x: List[T]) -> List[T]:
+        ...
+
+    def append(self, x: T) -> None:
+        pass
+
+    def pop(self, i: int = -1) -> T:
+        pass
+
+    def count(self, T) -> int:
+        pass
+
+    def extend(self, l: Iterable[T]) -> None:
+        pass
+
+    def insert(self, i: int, x: T) -> None:
+        pass
+
+    def sort(self) -> None:
+        pass
+
+    def reverse(self) -> None:
+        pass
+
+    def remove(self, o: T) -> None:
+        pass
+
+    def index(self, o: T) -> int:
+        pass
+
 
 class dict(Mapping[K, V]):
     @overload
-    def __init__(self, **kwargs: K) -> None: ...
+    def __init__(self, **kwargs: K) -> None:
+        ...
+
     @overload
-    def __init__(self, map: Mapping[K, V], **kwargs: V) -> None: ...
+    def __init__(self, map: Mapping[K, V], **kwargs: V) -> None:
+        ...
+
     @overload
-    def __init__(self, iterable: Iterable[Tuple[K, V]], **kwargs: V) -> None: ...
-    def __getitem__(self, key: K) -> V: pass
-    def __setitem__(self, k: K, v: V) -> None: pass
-    def __delitem__(self, k: K) -> None: pass
-    def __contains__(self, item: object) -> int: pass
-    def __iter__(self) -> Iterator[K]: pass
-    def __len__(self) -> int: pass
+    def __init__(self, iterable: Iterable[Tuple[K, V]], **kwargs: V) -> None:
+        ...
+
+    def __getitem__(self, key: K) -> V:
+        pass
+
+    def __setitem__(self, k: K, v: V) -> None:
+        pass
+
+    def __delitem__(self, k: K) -> None:
+        pass
+
+    def __contains__(self, item: object) -> int:
+        pass
+
+    def __iter__(self) -> Iterator[K]:
+        pass
+
+    def __len__(self) -> int:
+        pass
+
     @overload
-    def update(self, __m: Mapping[K, V], **kwargs: V) -> None: pass
+    def update(self, __m: Mapping[K, V], **kwargs: V) -> None:
+        pass
+
     @overload
-    def update(self, __m: Iterable[Tuple[K, V]], **kwargs: V) -> None: ...
+    def update(self, __m: Iterable[Tuple[K, V]], **kwargs: V) -> None:
+        ...
+
     @overload
-    def update(self, **kwargs: V) -> None: ...
-    def pop(self, x: int) -> K: pass
-    def keys(self) -> Iterable[K]: pass
-    def values(self) -> Iterable[V]: pass
-    def items(self) -> Iterable[Tuple[K, V]]: pass
-    def clear(self) -> None: pass
-    def copy(self) -> Dict[K, V]: pass
-    def setdefault(self, key: K, val: V = ...) -> V: pass
+    def update(self, **kwargs: V) -> None:
+        ...
+
+    def pop(self, x: int) -> K:
+        pass
+
+    def keys(self) -> Iterable[K]:
+        pass
+
+    def values(self) -> Iterable[V]:
+        pass
+
+    def items(self) -> Iterable[Tuple[K, V]]:
+        pass
+
+    def clear(self) -> None:
+        pass
+
+    def copy(self) -> Dict[K, V]:
+        pass
+
+    def setdefault(self, key: K, val: V = ...) -> V:
+        pass
+
 
 class set(Generic[T]):
-    def __init__(self, i: Optional[Iterable[T]] = None) -> None: pass
-    def __iter__(self) -> Iterator[T]: pass
-    def __len__(self) -> int: pass
-    def add(self, x: T) -> None: pass
-    def remove(self, x: T) -> None: pass
-    def discard(self, x: T) -> None: pass
-    def clear(self) -> None: pass
-    def pop(self) -> T: pass
-    def update(self, x: Iterable[S]) -> None: pass
-    def __or__(self, s: Union[Set[S], FrozenSet[S]]) -> Set[Union[T, S]]: ...
-    def __xor__(self, s: Union[Set[S], FrozenSet[S]]) -> Set[Union[T, S]]: ...
+    def __init__(self, i: Optional[Iterable[T]] = None) -> None:
+        pass
+
+    def __iter__(self) -> Iterator[T]:
+        pass
+
+    def __len__(self) -> int:
+        pass
+
+    def add(self, x: T) -> None:
+        pass
+
+    def remove(self, x: T) -> None:
+        pass
+
+    def discard(self, x: T) -> None:
+        pass
+
+    def clear(self) -> None:
+        pass
+
+    def pop(self) -> T:
+        pass
+
+    def update(self, x: Iterable[S]) -> None:
+        pass
+
+    def __or__(self, s: Union[Set[S], FrozenSet[S]]) -> Set[Union[T, S]]:
+        ...
+
+    def __xor__(self, s: Union[Set[S], FrozenSet[S]]) -> Set[Union[T, S]]:
+        ...
+
 
 class frozenset(Generic[T]):
-    def __init__(self, i: Optional[Iterable[T]] = None) -> None: pass
-    def __iter__(self) -> Iterator[T]: pass
-    def __len__(self) -> int: pass
-    def __or__(self, s: Union[Set[S], FrozenSet[S]]) -> FrozenSet[Union[T, S]]: ...
-    def __xor__(self, s: Union[Set[S], FrozenSet[S]]) -> FrozenSet[Union[T, S]]: ...
+    def __init__(self, i: Optional[Iterable[T]] = None) -> None:
+        pass
+
+    def __iter__(self) -> Iterator[T]:
+        pass
+
+    def __len__(self) -> int:
+        pass
+
+    def __or__(self, s: Union[Set[S], FrozenSet[S]]) -> FrozenSet[Union[T, S]]:
+        ...
+
+    def __xor__(self, s: Union[Set[S], FrozenSet[S]]) -> FrozenSet[Union[T, S]]:
+        ...
+
+
+class slice:
+    pass
 
-class slice: pass
 
 class range(Iterable[int]):
-    def __init__(self, x: int, y: int = ..., z: int = ...) -> None: pass
-    def __iter__(self) -> Iterator[int]: pass
-    def __len__(self) -> int: pass
-    def __next__(self) -> int: pass
+    def __init__(self, x: int, y: int = ..., z: int = ...) -> None:
+        pass
+
+    def __iter__(self) -> Iterator[int]:
+        pass
+
+    def __len__(self) -> int:
+        pass
+
+    def __next__(self) -> int:
+        pass
+
 
 class property:
-    def __init__(self, fget: Optional[Callable[[Any], Any]] = ...,
-                 fset: Optional[Callable[[Any, Any], None]] = ...,
-                 fdel: Optional[Callable[[Any], None]] = ...,
-                 doc: Optional[str] = ...) -> None: ...
-    def getter(self, fget: Callable[[Any], Any]) -> property: ...
-    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...
-    def deleter(self, fdel: Callable[[Any], None]) -> property: ...
-    def __get__(self, obj: Any, type: Optional[type] = ...) -> Any: ...
-    def __set__(self, obj: Any, value: Any) -> None: ...
-    def __delete__(self, obj: Any) -> None: ...
-    def fget(self) -> Any: ...
-    def fset(self, value: Any) -> None: ...
-    def fdel(self) -> None: ...
-
-class BaseException: pass
+    def __init__(
+        self,
+        fget: Optional[Callable[[Any], Any]] = ...,
+        fset: Optional[Callable[[Any, Any], None]] = ...,
+        fdel: Optional[Callable[[Any], None]] = ...,
+        doc: Optional[str] = ...,
+    ) -> None:
+        ...
+
+    def getter(self, fget: Callable[[Any], Any]) -> property:
+        ...
+
+    def setter(self, fset: Callable[[Any, Any], None]) -> property:
+        ...
+
+    def deleter(self, fdel: Callable[[Any], None]) -> property:
+        ...
+
+    def __get__(self, obj: Any, type: Optional[type] = ...) -> Any:
+        ...
+
+    def __set__(self, obj: Any, value: Any) -> None:
+        ...
+
+    def __delete__(self, obj: Any) -> None:
+        ...
+
+    def fget(self) -> Any:
+        ...
+
+    def fset(self, value: Any) -> None:
+        ...
+
+    def fdel(self) -> None:
+        ...
+
+
+class BaseException:
+    pass
+
 
 class Exception(BaseException):
-    def __init__(self, message: Optional[str] = None) -> None: pass
-
-class Warning(Exception): pass
-class UserWarning(Warning): pass
-class TypeError(Exception): pass
-class ValueError(Exception): pass
-class AttributeError(Exception): pass
-class ImportError(Exception): pass
-class NameError(Exception): pass
-class UnboundLocalError(NameError): pass
-class LookupError(Exception): pass
-class KeyError(LookupError): pass
-class IndexError(LookupError): pass
-class RuntimeError(Exception): pass
-class UnicodeEncodeError(RuntimeError): pass
-class UnicodeDecodeError(RuntimeError): pass
-class NotImplementedError(RuntimeError): pass
+    def __init__(self, message: Optional[str] = None) -> None:
+        pass
+
+
+class Warning(Exception):
+    pass
+
+
+class UserWarning(Warning):
+    pass
+
+
+class TypeError(Exception):
+    pass
+
+
+class ValueError(Exception):
+    pass
+
+
+class AttributeError(Exception):
+    pass
+
+
+class ImportError(Exception):
+    pass
+
+
+class NameError(Exception):
+    pass
+
+
+class UnboundLocalError(NameError):
+    pass
+
+
+class LookupError(Exception):
+    pass
+
+
+class KeyError(LookupError):
+    pass
+
+
+class IndexError(LookupError):
+    pass
+
+
+class RuntimeError(Exception):
+    pass
+
+
+class UnicodeEncodeError(RuntimeError):
+    pass
+
+
+class UnicodeDecodeError(RuntimeError):
+    pass
+
+
+class NotImplementedError(RuntimeError):
+    pass
+
 
 class StopIteration(Exception):
     value: Any
 
-class ArithmeticError(Exception): pass
-class ZeroDivisionError(ArithmeticError): pass
-class OverflowError(ArithmeticError): pass
 
-class GeneratorExit(BaseException): pass
+class ArithmeticError(Exception):
+    pass
+
+
+class ZeroDivisionError(ArithmeticError):
+    pass
+
+
+class OverflowError(ArithmeticError):
+    pass
+
+
+class GeneratorExit(BaseException):
+    pass
+
+
+def any(i: Iterable[T]) -> bool:
+    pass
+
+
+def all(i: Iterable[T]) -> bool:
+    pass
+
+
+def sum(i: Iterable[T]) -> int:
+    pass
+
+
+def reversed(object: Sequence[T]) -> Iterator[T]:
+    ...
+
+
+def id(o: object) -> int:
+    pass
+
 
-def any(i: Iterable[T]) -> bool: pass
-def all(i: Iterable[T]) -> bool: pass
-def sum(i: Iterable[T]) -> int: pass
-def reversed(object: Sequence[T]) -> Iterator[T]: ...
-def id(o: object) -> int: pass
 # This type is obviously wrong but the test stubs don't have Sized anymore
-def len(o: object) -> int: pass
-def print(*object) -> None: pass
-def isinstance(x: object, t: object) -> bool: pass
-def iter(i: Iterable[T]) -> Iterator[T]: pass
+def len(o: object) -> int:
+    pass
+
+
+def print(*object) -> None:
+    pass
+
+
+def isinstance(x: object, t: object) -> bool:
+    pass
+
+
+def iter(i: Iterable[T]) -> Iterator[T]:
+    pass
+
+
 @overload
-def next(i: Iterator[T]) -> T: pass
+def next(i: Iterator[T]) -> T:
+    pass
+
+
 @overload
-def next(i: Iterator[T], default: T) -> T: pass
-def hash(o: object) -> int: ...
-def globals() -> Dict[str, Any]: ...
-def getattr(obj: object, name: str, default: Any = None) -> Any: ...
-def setattr(obj: object, name: str, value: Any) -> None: ...
-def enumerate(x: Iterable[T]) -> Iterator[Tuple[int, T]]: ...
+def next(i: Iterator[T], default: T) -> T:
+    pass
+
+
+def hash(o: object) -> int:
+    ...
+
+
+def globals() -> Dict[str, Any]:
+    ...
+
+
+def getattr(obj: object, name: str, default: Any = None) -> Any:
+    ...
+
+
+def setattr(obj: object, name: str, value: Any) -> None:
+    ...
+
+
+def enumerate(x: Iterable[T]) -> Iterator[Tuple[int, T]]:
+    ...
+
+
 @overload
-def zip(x: Iterable[T], y: Iterable[S]) -> Iterator[Tuple[T, S]]: ...
+def zip(x: Iterable[T], y: Iterable[S]) -> Iterator[Tuple[T, S]]:
+    ...
+
+
 @overload
-def zip(x: Iterable[T], y: Iterable[S], z: Iterable[V]) -> Iterator[Tuple[T, S, V]]: ...
-def eval(e: str) -> Any: ...
-def abs(x: __SupportsAbs[T]) -> T: ...
+def zip(x: Iterable[T], y: Iterable[S], z: Iterable[V]) -> Iterator[Tuple[T, S, V]]:
+    ...
+
+
+def eval(e: str) -> Any:
+    ...
+
+
+def abs(x: __SupportsAbs[T]) -> T:
+    ...
+
+
 @overload
-def divmod(x: __SupportsDivMod[T_contra, T_co], y: T_contra) -> T_co: ...
+def divmod(x: __SupportsDivMod[T_contra, T_co], y: T_contra) -> T_co:
+    ...
+
+
 @overload
-def divmod(x: T_contra, y: __SupportsRDivMod[T_contra, T_co]) -> T_co: ...
+def divmod(x: T_contra, y: __SupportsRDivMod[T_contra, T_co]) -> T_co:
+    ...
+
+
 @overload
-def pow(base: __SupportsPow2[T_contra, T_co], exp: T_contra, mod: None = None) -> T_co: ...
+def pow(base: __SupportsPow2[T_contra, T_co], exp: T_contra, mod: None = None) -> T_co:
+    ...
+
+
 @overload
-def pow(base: __SupportsPow3NoneOnly[T_contra, T_co], exp: T_contra, mod: None = None) -> T_co: ...
+def pow(base: __SupportsPow3NoneOnly[T_contra, T_co], exp: T_contra, mod: None = None) -> T_co:
+    ...
+
+
 @overload
-def pow(base: __SupportsPow3[T_contra, _M, T_co], exp: T_contra, mod: _M) -> T_co: ...
-def exit() -> None: ...
-def min(x: T, y: T) -> T: ...
-def max(x: T, y: T) -> T: ...
-def repr(o: object) -> str: ...
-def ascii(o: object) -> str: ...
-def ord(o: object) -> int: ...
-def chr(i: int) -> str: ...
+def pow(base: __SupportsPow3[T_contra, _M, T_co], exp: T_contra, mod: _M) -> T_co:
+    ...
+
+
+def exit() -> None:
+    ...
+
+
+def min(x: T, y: T) -> T:
+    ...
+
+
+def max(x: T, y: T) -> T:
+    ...
+
+
+def repr(o: object) -> str:
+    ...
+
+
+def ascii(o: object) -> str:
+    ...
+
+
+def ord(o: object) -> int:
+    ...
+
+
+def chr(i: int) -> str:
+    ...
+
 
 # Dummy definitions.
-class classmethod: pass
-class staticmethod: pass
+class classmethod:
+    pass
+
+
+class staticmethod:
+    pass
+
 
 NotImplemented: Any = ...
diff --git a/mypyc/test-data/fixtures/testutil.py b/mypyc/test-data/fixtures/testutil.py
index 5a4b1d0f5..71b6e4c09 100644
--- a/mypyc/test-data/fixtures/testutil.py
+++ b/mypyc/test-data/fixtures/testutil.py
@@ -4,44 +4,52 @@ from contextlib import contextmanager
 from collections.abc import Iterator
 import math
 from typing import (
-    Any, Iterator, TypeVar, Generator, Optional, List, Tuple, Sequence,
-    Union, Callable, Awaitable,
+    Any,
+    Iterator,
+    TypeVar,
+    Generator,
+    Optional,
+    List,
+    Tuple,
+    Sequence,
+    Union,
+    Callable,
+    Awaitable,
 )
 from typing_extensions import Final
 
 FLOAT_MAGIC: Final = -113.0
 
 # Various different float values
-float_vals = [
-    float(n) * 0.25 for n in range(-10, 10)
-] + [
+float_vals = [float(n) * 0.25 for n in range(-10, 10)] + [
     -0.0,
-    1.0/3.0,
+    1.0 / 3.0,
     math.sqrt(2.0),
     1.23e200,
     -2.34e200,
     5.43e-100,
     -6.532e-200,
-    float('inf'),
-    -float('inf'),
-    float('nan'),
+    float("inf"),
+    -float("inf"),
+    float("nan"),
     FLOAT_MAGIC,
     math.pi,
     2.0 * math.pi,
     math.pi / 2.0,
     -math.pi / 2.0,
-    -1.7976931348623158e+308,  # Smallest finite value
+    -1.7976931348623158e308,  # Smallest finite value
     -2.2250738585072014e-308,  # Closest to zero negative normal value
-    -7.5491e-312,              # Arbitrary negative subnormal value
-    -5e-324,                   # Closest to zero negative subnormal value
-    1.7976931348623158e+308,   # Largest finite value
-    2.2250738585072014e-308,   # Closest to zero positive normal value
-    -6.3492e-312,              # Arbitrary positive subnormal value
-    5e-324,                    # Closest to zero positive subnormal value
+    -7.5491e-312,  # Arbitrary negative subnormal value
+    -5e-324,  # Closest to zero negative subnormal value
+    1.7976931348623158e308,  # Largest finite value
+    2.2250738585072014e-308,  # Closest to zero positive normal value
+    -6.3492e-312,  # Arbitrary positive subnormal value
+    5e-324,  # Closest to zero positive subnormal value
 ]
 
+
 @contextmanager
-def assertRaises(typ: type, msg: str = '') -> Iterator[None]:
+def assertRaises(typ: type, msg: str = "") -> Iterator[None]:
     try:
         yield
     except Exception as e:
@@ -50,19 +58,23 @@ def assertRaises(typ: type, msg: str = '') -> Iterator[None]:
     else:
         assert False, f"Expected {typ.__name__} but got no exception"
 
+
 def assertDomainError() -> Any:
     return assertRaises(ValueError, "math domain error")
 
+
 def assertMathRangeError() -> Any:
     return assertRaises(OverflowError, "math range error")
 
-T = TypeVar('T')
-U = TypeVar('U')
-V = TypeVar('V')
 
-def run_generator(gen: Generator[T, V, U],
-                  inputs: Optional[List[V]] = None,
-                  p: bool = False) -> Tuple[Sequence[T], Union[U, str]]:
+T = TypeVar("T")
+U = TypeVar("U")
+V = TypeVar("V")
+
+
+def run_generator(
+    gen: Generator[T, V, U], inputs: Optional[List[V]] = None, p: bool = False
+) -> Tuple[Sequence[T], Union[U, str]]:
     res: List[T] = []
     i = -1
     while True:
@@ -70,7 +82,7 @@ def run_generator(gen: Generator[T, V, U],
             if i >= 0 and inputs:
                 # ... fixtures don't have send
                 val = gen.send(inputs[i])  # type: ignore
-            elif not hasattr(gen, '__next__'):  # type: ignore
+            elif not hasattr(gen, "__next__"):  # type: ignore
                 val = gen.send(None)  # type: ignore
             else:
                 val = next(gen)
@@ -83,7 +95,8 @@ def run_generator(gen: Generator[T, V, U],
         res.append(val)
         i += 1
 
-F = TypeVar('F', bound=Callable)
+
+F = TypeVar("F", bound=Callable)
 
 
 class async_val(Awaitable[V]):
@@ -100,4 +113,5 @@ class async_val(Awaitable[V]):
 def make_python_function(f: F) -> F:
     def g(*args: Any, **kwargs: Any) -> Any:
         return f(*args, **kwargs)
+
     return g  # type: ignore
diff --git a/mypyc/test-data/fixtures/typing-full.pyi b/mypyc/test-data/fixtures/typing-full.pyi
index 52bca09a1..250ac4153 100644
--- a/mypyc/test-data/fixtures/typing-full.pyi
+++ b/mypyc/test-data/fixtures/typing-full.pyi
@@ -8,7 +8,8 @@
 
 from abc import abstractmethod, ABCMeta
 
-class GenericMeta(type): pass
+class GenericMeta(type):
+    pass
 
 cast = 0
 overload = 0
@@ -31,12 +32,12 @@ TypedDict = 0
 NoReturn = 0
 NewType = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-T_contra = TypeVar('T_contra', contravariant=True)
-U = TypeVar('U')
-V = TypeVar('V')
-S = TypeVar('S')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+T_contra = TypeVar("T_contra", contravariant=True)
+U = TypeVar("U")
+V = TypeVar("V")
+S = TypeVar("S")
 
 # Note: definitions below are different from typeshed, variances are declared
 # to silence the protocol variance checks. Maybe it is better to use type: ignore?
@@ -45,113 +46,137 @@ S = TypeVar('S')
 class Container(Protocol[T_co]):
     @abstractmethod
     # Use int because bool isn't in the default test builtins
-    def __contains__(self, arg: object) -> int: pass
+    def __contains__(self, arg: object) -> int:
+        pass
 
 @runtime_checkable
 class Sized(Protocol):
     @abstractmethod
-    def __len__(self) -> int: pass
+    def __len__(self) -> int:
+        pass
 
 @runtime_checkable
 class Iterable(Protocol[T_co]):
     @abstractmethod
-    def __iter__(self) -> 'Iterator[T_co]': pass
+    def __iter__(self) -> "Iterator[T_co]":
+        pass
 
 @runtime_checkable
 class Iterator(Iterable[T_co], Protocol):
     @abstractmethod
-    def __next__(self) -> T_co: pass
+    def __next__(self) -> T_co:
+        pass
 
 class Generator(Iterator[T], Generic[T, U, V]):
     @abstractmethod
-    def send(self, value: U) -> T: pass
-
+    def send(self, value: U) -> T:
+        pass
     @abstractmethod
-    def throw(self, typ: Any, val: Any=None, tb: Any=None) -> None: pass
-
+    def throw(self, typ: Any, val: Any = None, tb: Any = None) -> None:
+        pass
     @abstractmethod
-    def close(self) -> None: pass
-
+    def close(self) -> None:
+        pass
     @abstractmethod
-    def __iter__(self) -> 'Generator[T, U, V]': pass
+    def __iter__(self) -> "Generator[T, U, V]":
+        pass
 
 class AsyncGenerator(AsyncIterator[T], Generic[T, U]):
     @abstractmethod
-    def __anext__(self) -> Awaitable[T]: pass
-
+    def __anext__(self) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def asend(self, value: U) -> Awaitable[T]: pass
-
+    def asend(self, value: U) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def athrow(self, typ: Any, val: Any=None, tb: Any=None) -> Awaitable[T]: pass
-
+    def athrow(self, typ: Any, val: Any = None, tb: Any = None) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def aclose(self) -> Awaitable[T]: pass
-
+    def aclose(self) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def __aiter__(self) -> 'AsyncGenerator[T, U]': pass
+    def __aiter__(self) -> "AsyncGenerator[T, U]":
+        pass
 
 @runtime_checkable
 class Awaitable(Protocol[T]):
     @abstractmethod
-    def __await__(self) -> Generator[Any, Any, T]: pass
+    def __await__(self) -> Generator[Any, Any, T]:
+        pass
 
 class AwaitableGenerator(Generator[T, U, V], Awaitable[V], Generic[T, U, V, S], metaclass=ABCMeta):
     pass
 
 class Coroutine(Awaitable[V], Generic[T, U, V]):
     @abstractmethod
-    def send(self, value: U) -> T: pass
-
+    def send(self, value: U) -> T:
+        pass
     @abstractmethod
-    def throw(self, typ: Any, val: Any=None, tb: Any=None) -> None: pass
-
+    def throw(self, typ: Any, val: Any = None, tb: Any = None) -> None:
+        pass
     @abstractmethod
-    def close(self) -> None: pass
+    def close(self) -> None:
+        pass
 
 @runtime_checkable
 class AsyncIterable(Protocol[T]):
     @abstractmethod
-    def __aiter__(self) -> 'AsyncIterator[T]': pass
+    def __aiter__(self) -> "AsyncIterator[T]":
+        pass
 
 @runtime_checkable
 class AsyncIterator(AsyncIterable[T], Protocol):
-    def __aiter__(self) -> 'AsyncIterator[T]': return self
+    def __aiter__(self) -> "AsyncIterator[T]":
+        return self
     @abstractmethod
-    def __anext__(self) -> Awaitable[T]: pass
+    def __anext__(self) -> Awaitable[T]:
+        pass
 
 class Sequence(Iterable[T_co], Container[T_co]):
     @abstractmethod
-    def __getitem__(self, n: Any) -> T_co: pass
+    def __getitem__(self, n: Any) -> T_co:
+        pass
 
 class Mapping(Iterable[T], Generic[T, T_co], metaclass=ABCMeta):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
     @overload
-    def get(self, k: T) -> Optional[T_co]: pass
+    def get(self, k: T) -> Optional[T_co]:
+        pass
     @overload
-    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]: pass
-    def values(self) -> Iterable[T_co]: pass  # Approximate return type
-    def items(self) -> Iterable[Tuple[T, T_co]]: pass  # Approximate return type
+    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]:
+        pass
+    def values(self) -> Iterable[T_co]:
+        pass  # Approximate return type
+    def items(self) -> Iterable[Tuple[T, T_co]]:
+        pass  # Approximate return type
     def __len__(self) -> int: ...
-    def __contains__(self, arg: object) -> int: pass
+    def __contains__(self, arg: object) -> int:
+        pass
 
 class MutableMapping(Mapping[T, U], metaclass=ABCMeta):
-    def __setitem__(self, k: T, v: U) -> None: pass
+    def __setitem__(self, k: T, v: U) -> None:
+        pass
 
 class SupportsInt(Protocol):
-    def __int__(self) -> int: pass
+    def __int__(self) -> int:
+        pass
 
 class SupportsFloat(Protocol):
-    def __float__(self) -> float: pass
+    def __float__(self) -> float:
+        pass
 
 def runtime_checkable(cls: T) -> T:
     return cls
 
 class ContextManager(Generic[T]):
-    def __enter__(self) -> T: pass
+    def __enter__(self) -> T:
+        pass
     # Use Any because not all the precise types are in the fixtures.
-    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any: pass
+    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
+        pass
 
 TYPE_CHECKING = 1
 
diff --git a/pyproject.toml b/pyproject.toml
index 3d100dff5..a06acccf2 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -23,8 +23,6 @@ target-version = ["py37", "py38", "py39", "py310", "py311"]
 skip-magic-trailing-comma = true
 force-exclude = '''
 ^/mypy/typeshed|
-^/mypyc/test-data|
-^/test-data
 '''
 
 [tool.isort]
diff --git a/test-data/packages/modulefinder-site-packages/foo-stubs/bar.pyi b/test-data/packages/modulefinder-site-packages/foo-stubs/bar.pyi
index bf896e8cd..833a52007 100644
--- a/test-data/packages/modulefinder-site-packages/foo-stubs/bar.pyi
+++ b/test-data/packages/modulefinder-site-packages/foo-stubs/bar.pyi
@@ -1 +1 @@
-bar_var: str
\ No newline at end of file
+bar_var: str
diff --git a/test-data/packages/modulefinder-site-packages/foo/bar.py b/test-data/packages/modulefinder-site-packages/foo/bar.py
index a1c3b50ee..7782aba46 100644
--- a/test-data/packages/modulefinder-site-packages/foo/bar.py
+++ b/test-data/packages/modulefinder-site-packages/foo/bar.py
@@ -1 +1 @@
-bar_var = "bar"
\ No newline at end of file
+bar_var = "bar"
diff --git a/test-data/packages/modulefinder-site-packages/ns_pkg_typed/a.py b/test-data/packages/modulefinder-site-packages/ns_pkg_typed/a.py
index 9d71311c4..c0cca79b8 100644
--- a/test-data/packages/modulefinder-site-packages/ns_pkg_typed/a.py
+++ b/test-data/packages/modulefinder-site-packages/ns_pkg_typed/a.py
@@ -1 +1 @@
-a_var = "a"
\ No newline at end of file
+a_var = "a"
diff --git a/test-data/packages/modulefinder-site-packages/ns_pkg_typed/b/c.py b/test-data/packages/modulefinder-site-packages/ns_pkg_typed/b/c.py
index 003a29a2e..0ed729e24 100644
--- a/test-data/packages/modulefinder-site-packages/ns_pkg_typed/b/c.py
+++ b/test-data/packages/modulefinder-site-packages/ns_pkg_typed/b/c.py
@@ -1 +1 @@
-c_var = "c"
\ No newline at end of file
+c_var = "c"
diff --git a/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/a.py b/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/a.py
index 9d71311c4..c0cca79b8 100644
--- a/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/a.py
+++ b/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/a.py
@@ -1 +1 @@
-a_var = "a"
\ No newline at end of file
+a_var = "a"
diff --git a/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/b/c.py b/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/b/c.py
index 003a29a2e..0ed729e24 100644
--- a/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/b/c.py
+++ b/test-data/packages/modulefinder-site-packages/ns_pkg_untyped/b/c.py
@@ -1 +1 @@
-c_var = "c"
\ No newline at end of file
+c_var = "c"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_typed/__init__.py b/test-data/packages/modulefinder-site-packages/pkg_typed/__init__.py
index 88ed99fb5..f49ab244c 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_typed/__init__.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_typed/__init__.py
@@ -1 +1 @@
-pkg_typed_var = "pkg_typed"
\ No newline at end of file
+pkg_typed_var = "pkg_typed"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_typed/a.py b/test-data/packages/modulefinder-site-packages/pkg_typed/a.py
index 9d71311c4..c0cca79b8 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_typed/a.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_typed/a.py
@@ -1 +1 @@
-a_var = "a"
\ No newline at end of file
+a_var = "a"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_typed/b/__init__.py b/test-data/packages/modulefinder-site-packages/pkg_typed/b/__init__.py
index de0052886..6cea6ed42 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_typed/b/__init__.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_typed/b/__init__.py
@@ -1 +1 @@
-b_var = "b"
\ No newline at end of file
+b_var = "b"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_typed/b/c.py b/test-data/packages/modulefinder-site-packages/pkg_typed/b/c.py
index 003a29a2e..0ed729e24 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_typed/b/c.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_typed/b/c.py
@@ -1 +1 @@
-c_var = "c"
\ No newline at end of file
+c_var = "c"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_untyped/__init__.py b/test-data/packages/modulefinder-site-packages/pkg_untyped/__init__.py
index c7ff39c11..4960ea0a9 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_untyped/__init__.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_untyped/__init__.py
@@ -1 +1 @@
-pkg_untyped_var = "pkg_untyped"
\ No newline at end of file
+pkg_untyped_var = "pkg_untyped"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_untyped/a.py b/test-data/packages/modulefinder-site-packages/pkg_untyped/a.py
index 9d71311c4..c0cca79b8 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_untyped/a.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_untyped/a.py
@@ -1 +1 @@
-a_var = "a"
\ No newline at end of file
+a_var = "a"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_untyped/b/__init__.py b/test-data/packages/modulefinder-site-packages/pkg_untyped/b/__init__.py
index de0052886..6cea6ed42 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_untyped/b/__init__.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_untyped/b/__init__.py
@@ -1 +1 @@
-b_var = "b"
\ No newline at end of file
+b_var = "b"
diff --git a/test-data/packages/modulefinder-site-packages/pkg_untyped/b/c.py b/test-data/packages/modulefinder-site-packages/pkg_untyped/b/c.py
index 003a29a2e..0ed729e24 100644
--- a/test-data/packages/modulefinder-site-packages/pkg_untyped/b/c.py
+++ b/test-data/packages/modulefinder-site-packages/pkg_untyped/b/c.py
@@ -1 +1 @@
-c_var = "c"
\ No newline at end of file
+c_var = "c"
diff --git a/test-data/packages/modulefinder-site-packages/standalone.py b/test-data/packages/modulefinder-site-packages/standalone.py
index 35b38168f..ce436beef 100644
--- a/test-data/packages/modulefinder-site-packages/standalone.py
+++ b/test-data/packages/modulefinder-site-packages/standalone.py
@@ -1 +1 @@
-standalone_var = "standalone"
\ No newline at end of file
+standalone_var = "standalone"
diff --git a/test-data/packages/typedpkg-stubs/setup.py b/test-data/packages/typedpkg-stubs/setup.py
index 4948dc6a0..037bfe972 100644
--- a/test-data/packages/typedpkg-stubs/setup.py
+++ b/test-data/packages/typedpkg-stubs/setup.py
@@ -5,9 +5,9 @@ This setup file installs packages to test mypy's PEP 561 implementation
 from setuptools import setup
 
 setup(
-    name='typedpkg-stubs',
+    name="typedpkg-stubs",
     author="The mypy team",
-    version='0.1',
-    package_data={'typedpkg-stubs': ['sample.pyi', '__init__.pyi', 'py.typed']},
-    packages=['typedpkg-stubs'],
+    version="0.1",
+    package_data={"typedpkg-stubs": ["sample.pyi", "__init__.pyi", "py.typed"]},
+    packages=["typedpkg-stubs"],
 )
diff --git a/test-data/packages/typedpkg-stubs/typedpkg-stubs/sample.pyi b/test-data/packages/typedpkg-stubs/typedpkg-stubs/sample.pyi
index 355deefd6..e0fa2d9ed 100644
--- a/test-data/packages/typedpkg-stubs/typedpkg-stubs/sample.pyi
+++ b/test-data/packages/typedpkg-stubs/typedpkg-stubs/sample.pyi
@@ -1,2 +1,3 @@
 from typing import Iterable, List
+
 def ex(a: Iterable[str]) -> List[str]: ...
diff --git a/test-data/packages/typedpkg/setup.py b/test-data/packages/typedpkg/setup.py
index 11bcfb11a..d154e14e0 100644
--- a/test-data/packages/typedpkg/setup.py
+++ b/test-data/packages/typedpkg/setup.py
@@ -5,11 +5,11 @@ This setup file installs packages to test mypy's PEP 561 implementation
 from setuptools import setup
 
 setup(
-    name='typedpkg',
+    name="typedpkg",
     author="The mypy team",
-    version='0.1',
-    package_data={'typedpkg': ['py.typed']},
-    packages=['typedpkg', 'typedpkg.pkg'],
+    version="0.1",
+    package_data={"typedpkg": ["py.typed"]},
+    packages=["typedpkg", "typedpkg.pkg"],
     include_package_data=True,
     zip_safe=False,
 )
diff --git a/test-data/packages/typedpkg_ns_a/setup.py b/test-data/packages/typedpkg_ns_a/setup.py
index 3dab731ca..4b348074b 100644
--- a/test-data/packages/typedpkg_ns_a/setup.py
+++ b/test-data/packages/typedpkg_ns_a/setup.py
@@ -1,10 +1,10 @@
 from setuptools import setup
 
 setup(
-    name='typedpkg_namespace.alpha',
-    version='1.0.0',
-    namespace_packages=['typedpkg_ns'],
+    name="typedpkg_namespace.alpha",
+    version="1.0.0",
+    namespace_packages=["typedpkg_ns"],
     zip_safe=False,
-    package_data={'typedpkg_ns.a': ['py.typed']},
-    packages=['typedpkg_ns.a'],
+    package_data={"typedpkg_ns.a": ["py.typed"]},
+    packages=["typedpkg_ns.a"],
 )
diff --git a/test-data/packages/typedpkg_ns_b-stubs/setup.py b/test-data/packages/typedpkg_ns_b-stubs/setup.py
index a5d7df83e..cf6a64b9d 100644
--- a/test-data/packages/typedpkg_ns_b-stubs/setup.py
+++ b/test-data/packages/typedpkg_ns_b-stubs/setup.py
@@ -5,10 +5,10 @@ This setup file installs packages to test mypy's PEP 561 implementation
 from distutils.core import setup
 
 setup(
-    name='typedpkg_ns_b-stubs',
+    name="typedpkg_ns_b-stubs",
     author="The mypy team",
-    version='0.1',
-    namespace_packages=['typedpkg_ns-stubs'],
-    package_data={'typedpkg_ns-stubs.b': ['__init__.pyi', 'bbb.pyi']},
-    packages=['typedpkg_ns-stubs.b'],
+    version="0.1",
+    namespace_packages=["typedpkg_ns-stubs"],
+    package_data={"typedpkg_ns-stubs.b": ["__init__.pyi", "bbb.pyi"]},
+    packages=["typedpkg_ns-stubs.b"],
 )
diff --git a/test-data/packages/typedpkg_ns_b/setup.py b/test-data/packages/typedpkg_ns_b/setup.py
index 4f0d0d954..7753ea036 100644
--- a/test-data/packages/typedpkg_ns_b/setup.py
+++ b/test-data/packages/typedpkg_ns_b/setup.py
@@ -1,10 +1,10 @@
 from setuptools import setup
 
 setup(
-    name='typedpkg_namespace.beta',
-    version='1.0.0',
-    namespace_packages=['typedpkg_ns'],
+    name="typedpkg_namespace.beta",
+    version="1.0.0",
+    namespace_packages=["typedpkg_ns"],
     zip_safe=False,
-    package_data={'typedpkg_ns.b': []},
-    packages=['typedpkg_ns.b'],
+    package_data={"typedpkg_ns.b": []},
+    packages=["typedpkg_ns.b"],
 )
diff --git a/test-data/pybind11_mypy_demo/setup.py b/test-data/pybind11_mypy_demo/setup.py
index 0da1cfbce..be53b64b6 100644
--- a/test-data/pybind11_mypy_demo/setup.py
+++ b/test-data/pybind11_mypy_demo/setup.py
@@ -3,16 +3,6 @@ from pybind11.setup_helpers import Pybind11Extension
 from setuptools import setup
 
 # Documentation: https://pybind11.readthedocs.io/en/stable/compiling.html
-ext_modules = [
-    Pybind11Extension(
-        "pybind11_mypy_demo",
-        ["src/main.cpp"],
-        cxx_std=17,
-    ),
-]
+ext_modules = [Pybind11Extension("pybind11_mypy_demo", ["src/main.cpp"], cxx_std=17)]
 
-setup(
-    name="pybind11-mypy-demo",
-    version="0.0.1",
-    ext_modules=ext_modules,
-)
+setup(name="pybind11-mypy-demo", version="0.0.1", ext_modules=ext_modules)
diff --git a/test-data/pybind11_mypy_demo/stubgen/pybind11_mypy_demo/basics.pyi b/test-data/pybind11_mypy_demo/stubgen/pybind11_mypy_demo/basics.pyi
index ab5a4f4e7..3fc48b3ef 100644
--- a/test-data/pybind11_mypy_demo/stubgen/pybind11_mypy_demo/basics.pyi
+++ b/test-data/pybind11_mypy_demo/stubgen/pybind11_mypy_demo/basics.pyi
@@ -1,6 +1,7 @@
 from typing import ClassVar
 
 from typing import overload
+
 PI: float
 
 class Point:
diff --git a/test-data/unit/fixtures/__init_subclass__.pyi b/test-data/unit/fixtures/__init_subclass__.pyi
index b4618c282..ad7a286f3 100644
--- a/test-data/unit/fixtures/__init_subclass__.pyi
+++ b/test-data/unit/fixtures/__init_subclass__.pyi
@@ -3,12 +3,23 @@
 from typing import Mapping, Iterable  # needed for ArgumentInferContext
 
 class object:
-    def __init_subclass__(cls) -> None: pass
+    def __init_subclass__(cls) -> None:
+        pass
 
-class type: pass
+class type:
+    pass
 
-class int: pass
-class bool: pass
-class str: pass
-class function: pass
-class dict: pass
+class int:
+    pass
+
+class bool:
+    pass
+
+class str:
+    pass
+
+class function:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/__new__.pyi b/test-data/unit/fixtures/__new__.pyi
index 401de6fb9..1fed6b508 100644
--- a/test-data/unit/fixtures/__new__.pyi
+++ b/test-data/unit/fixtures/__new__.pyi
@@ -3,17 +3,28 @@
 from typing import Any
 
 class object:
-    def __init__(self) -> None: pass
-
+    def __init__(self) -> None:
+        pass
     __class__ = object
 
-    def __new__(cls) -> Any: pass
+    def __new__(cls) -> Any:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
+
+class int:
+    pass
+
+class bool:
+    pass
+
+class str:
+    pass
+
+class function:
+    pass
 
-class int: pass
-class bool: pass
-class str: pass
-class function: pass
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/alias.pyi b/test-data/unit/fixtures/alias.pyi
index 2ec7703f0..f9f4ecce1 100644
--- a/test-data/unit/fixtures/alias.pyi
+++ b/test-data/unit/fixtures/alias.pyi
@@ -3,14 +3,23 @@
 from typing import Mapping, Iterable  # needed for `ArgumentInferContext`
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
+
+class int:
+    pass
+
+class str:
+    pass
 
-class int: pass
-class str: pass
-class function: pass
+class function:
+    pass
 
 bytes = str
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/any.pyi b/test-data/unit/fixtures/any.pyi
index b1f8d83bf..f86ccc9d7 100644
--- a/test-data/unit/fixtures/any.pyi
+++ b/test-data/unit/fixtures/any.pyi
@@ -1,10 +1,15 @@
 from typing import TypeVar, Iterable
 
-T = TypeVar('T')
+T = TypeVar("T")
 
-class int: pass
-class str: pass
+class int:
+    pass
 
-def any(i: Iterable[T]) -> bool: pass
+class str:
+    pass
 
-class dict: pass
+def any(i: Iterable[T]) -> bool:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/args.pyi b/test-data/unit/fixtures/args.pyi
index 0020d9cef..58bb4344d 100644
--- a/test-data/unit/fixtures/args.pyi
+++ b/test-data/unit/fixtures/args.pyi
@@ -3,33 +3,55 @@
 import _typeshed
 from typing import TypeVar, Generic, Iterable, Sequence, Tuple, Dict, Any, overload, Mapping
 
-Tco = TypeVar('Tco', covariant=True)
-T = TypeVar('T')
-S = TypeVar('S')
+Tco = TypeVar("Tco", covariant=True)
+T = TypeVar("T")
+S = TypeVar("S")
 
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, o: object) -> bool: pass
-    def __ne__(self, o: object) -> bool: pass
+    def __init__(self) -> None:
+        pass
+    def __eq__(self, o: object) -> bool:
+        pass
+    def __ne__(self, o: object) -> bool:
+        pass
 
 class type:
     @overload
-    def __init__(self, o: object) -> None: pass
+    def __init__(self, o: object) -> None:
+        pass
     @overload
-    def __init__(self, name: str, bases: Tuple[type, ...], dict: Dict[str, Any]) -> None: pass
-    def __call__(self, *args: Any, **kwargs: Any) -> Any: pass
+    def __init__(self, name: str, bases: Tuple[type, ...], dict: Dict[str, Any]) -> None:
+        pass
+    def __call__(self, *args: Any, **kwargs: Any) -> Any:
+        pass
 
-class tuple(Iterable[Tco], Generic[Tco]): pass
+class tuple(Iterable[Tco], Generic[Tco]):
+    pass
 
-class dict(Mapping[T, S], Generic[T, S]): pass
+class dict(Mapping[T, S], Generic[T, S]):
+    pass
 
-class list(Sequence[T], Generic[T]): pass
+class list(Sequence[T], Generic[T]):
+    pass
 
 class int:
-    def __eq__(self, o: object) -> bool: pass
-class float: pass
-class str: pass
-class bytes: pass
-class bool: pass
-class function: pass
-class ellipsis: pass
+    def __eq__(self, o: object) -> bool:
+        pass
+
+class float:
+    pass
+
+class str:
+    pass
+
+class bytes:
+    pass
+
+class bool:
+    pass
+
+class function:
+    pass
+
+class ellipsis:
+    pass
diff --git a/test-data/unit/fixtures/async_await.pyi b/test-data/unit/fixtures/async_await.pyi
index 96ade8811..a18d193b4 100644
--- a/test-data/unit/fixtures/async_await.pyi
+++ b/test-data/unit/fixtures/async_await.pyi
@@ -1,26 +1,57 @@
 import typing
 
-T = typing.TypeVar('T')
-U = typing.TypeVar('U')
+T = typing.TypeVar("T")
+U = typing.TypeVar("U")
+
 class list(typing.Sequence[T]):
     def __iter__(self) -> typing.Iterator[T]: ...
     def __getitem__(self, i: int) -> T: ...
     def __contains__(self, item: object) -> bool: ...
 
 class object:
-    def __init__(self) -> None: pass
-class type: pass
-class function: pass
-class int: pass
-class float: pass
-class str: pass
-class bool(int): pass
-class dict(typing.Generic[T, U]): pass
-class set(typing.Generic[T]): pass
-class tuple(typing.Generic[T]): pass
-class BaseException: pass
-class StopIteration(BaseException): pass
-class StopAsyncIteration(BaseException): pass
-def iter(obj: typing.Any) -> typing.Any: pass
-def next(obj: typing.Any) -> typing.Any: pass
+    def __init__(self) -> None:
+        pass
+
+class type:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class float:
+    pass
+
+class str:
+    pass
+
+class bool(int):
+    pass
+
+class dict(typing.Generic[T, U]):
+    pass
+
+class set(typing.Generic[T]):
+    pass
+
+class tuple(typing.Generic[T]):
+    pass
+
+class BaseException:
+    pass
+
+class StopIteration(BaseException):
+    pass
+
+class StopAsyncIteration(BaseException):
+    pass
+
+def iter(obj: typing.Any) -> typing.Any:
+    pass
+
+def next(obj: typing.Any) -> typing.Any:
+    pass
+
 class ellipsis: ...
diff --git a/test-data/unit/fixtures/bool.pyi b/test-data/unit/fixtures/bool.pyi
index bc58a22b9..5c1029e78 100644
--- a/test-data/unit/fixtures/bool.pyi
+++ b/test-data/unit/fixtures/bool.pyi
@@ -1,20 +1,45 @@
 # builtins stub used in boolean-related test cases.
 from typing import Generic, TypeVar
-T = TypeVar('T')
+
+T = TypeVar("T")
 
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, other: object) -> bool: pass
-    def __ne__(self, other: object) -> bool: pass
-
-class type: pass
-class tuple(Generic[T]): pass
-class function: pass
-class int: pass
-class bool(int): pass
-class float: pass
-class str: pass
-class ellipsis: pass
-class list(Generic[T]): pass
-class property: pass
-class dict: pass
+    def __init__(self) -> None:
+        pass
+    def __eq__(self, other: object) -> bool:
+        pass
+    def __ne__(self, other: object) -> bool:
+        pass
+
+class type:
+    pass
+
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class bool(int):
+    pass
+
+class float:
+    pass
+
+class str:
+    pass
+
+class ellipsis:
+    pass
+
+class list(Generic[T]):
+    pass
+
+class property:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/callable.pyi b/test-data/unit/fixtures/callable.pyi
index 44abf0691..e504a8d71 100644
--- a/test-data/unit/fixtures/callable.pyi
+++ b/test-data/unit/fixtures/callable.pyi
@@ -1,31 +1,55 @@
 from typing import Generic, Tuple, TypeVar, Union
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
-class tuple(Generic[T]): pass
+class tuple(Generic[T]):
+    pass
 
-class classmethod: pass
-class staticmethod: pass
-class function: pass
+class classmethod:
+    pass
 
-def isinstance(x: object, t: Union[type, Tuple[type, ...]]) -> bool: pass
+class staticmethod:
+    pass
 
-def callable(x: object) -> bool: pass
+class function:
+    pass
+
+def isinstance(x: object, t: Union[type, Tuple[type, ...]]) -> bool:
+    pass
+
+def callable(x: object) -> bool:
+    pass
 
 class int:
-    def __add__(self, other: 'int') -> 'int': pass
-    def __eq__(self, other: 'int') -> 'bool': pass
-class float: pass
-class bool(int): pass
+    def __add__(self, other: "int") -> "int":
+        pass
+    def __eq__(self, other: "int") -> "bool":
+        pass
+
+class float:
+    pass
+
+class bool(int):
+    pass
+
 class str:
-    def __add__(self, other: 'str') -> 'str': pass
-    def __eq__(self, other: 'str') -> bool: pass
-class ellipsis: pass
+    def __add__(self, other: "str") -> "str":
+        pass
+    def __eq__(self, other: "str") -> bool:
+        pass
+
+class ellipsis:
+    pass
+
 class list: ...
-class dict: pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/classmethod.pyi b/test-data/unit/fixtures/classmethod.pyi
index 97e018b1d..b8fa8804c 100644
--- a/test-data/unit/fixtures/classmethod.pyi
+++ b/test-data/unit/fixtures/classmethod.pyi
@@ -1,31 +1,52 @@
 import typing
 
-_T = typing.TypeVar('_T')
+_T = typing.TypeVar("_T")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
-    def mro(self) -> typing.Any: pass
+    def __init__(self, x) -> None:
+        pass
+    def mro(self) -> typing.Any:
+        pass
 
-class function: pass
+class function:
+    pass
 
 # Dummy definitions.
-class classmethod: pass
-class staticmethod: pass
+class classmethod:
+    pass
+
+class staticmethod:
+    pass
 
 class int:
     @classmethod
-    def from_bytes(cls, bytes: bytes, byteorder: str) -> int: pass
+    def from_bytes(cls, bytes: bytes, byteorder: str) -> int:
+        pass
+
+class float:
+    pass
+
+class str:
+    pass
+
+class bytes:
+    pass
+
+class bool:
+    pass
+
+class ellipsis:
+    pass
 
-class float: pass
-class str: pass
-class bytes: pass
-class bool: pass
-class ellipsis: pass
+class tuple(typing.Generic[_T]):
+    pass
 
-class tuple(typing.Generic[_T]): pass
+class list:
+    pass
 
-class list: pass
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/complex.pyi b/test-data/unit/fixtures/complex.pyi
index 880ec3dd4..eee110e80 100644
--- a/test-data/unit/fixtures/complex.pyi
+++ b/test-data/unit/fixtures/complex.pyi
@@ -2,12 +2,26 @@
 # Please don't add tuple to this file, it is used to test incomplete fixtures.
 
 class object:
-    def __init__(self): pass
-
-class type: pass
-class function: pass
-class int: pass
-class float: pass
-class complex: pass
-class str: pass
-class dict: pass
+    def __init__(self):
+        pass
+
+class type:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class float:
+    pass
+
+class complex:
+    pass
+
+class str:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/complex_tuple.pyi b/test-data/unit/fixtures/complex_tuple.pyi
index 81f1d33d1..066df06f5 100644
--- a/test-data/unit/fixtures/complex_tuple.pyi
+++ b/test-data/unit/fixtures/complex_tuple.pyi
@@ -1,16 +1,34 @@
 from typing import Generic, TypeVar
-_T = TypeVar('_T')
+
+_T = TypeVar("_T")
 
 class object:
-    def __init__(self): pass
-
-class tuple(Generic[_T]): pass
-
-class type: pass
-class function: pass
-class int: pass
-class float: pass
-class complex: pass
-class str: pass
-class ellipsis: pass
-class dict: pass
+    def __init__(self):
+        pass
+
+class tuple(Generic[_T]):
+    pass
+
+class type:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class float:
+    pass
+
+class complex:
+    pass
+
+class str:
+    pass
+
+class ellipsis:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/dataclasses.pyi b/test-data/unit/fixtures/dataclasses.pyi
index 710b8659d..ee1a33e72 100644
--- a/test-data/unit/fixtures/dataclasses.pyi
+++ b/test-data/unit/fixtures/dataclasses.pyi
@@ -1,50 +1,93 @@
 import _typeshed
 from typing import (
-    Generic, Iterator, Iterable, Mapping, Optional, Sequence, Tuple,
-    TypeVar, Union, overload,
+    Generic,
+    Iterator,
+    Iterable,
+    Mapping,
+    Optional,
+    Sequence,
+    Tuple,
+    TypeVar,
+    Union,
+    overload,
 )
 
-_T = TypeVar('_T')
-_U = TypeVar('_U')
-KT = TypeVar('KT')
-VT = TypeVar('VT')
+_T = TypeVar("_T")
+_U = TypeVar("_U")
+KT = TypeVar("KT")
+VT = TypeVar("VT")
 
 class object:
-    def __init__(self) -> None: pass
-    def __init_subclass__(cls) -> None: pass
-    def __eq__(self, o: object) -> bool: pass
-    def __ne__(self, o: object) -> bool: pass
-
-class type: pass
-class ellipsis: pass
-class tuple(Generic[_T]): pass
-class int: pass
-class float: pass
-class bytes: pass
-class str: pass
-class bool(int): pass
+    def __init__(self) -> None:
+        pass
+    def __init_subclass__(cls) -> None:
+        pass
+    def __eq__(self, o: object) -> bool:
+        pass
+    def __ne__(self, o: object) -> bool:
+        pass
+
+class type:
+    pass
+
+class ellipsis:
+    pass
+
+class tuple(Generic[_T]):
+    pass
+
+class int:
+    pass
+
+class float:
+    pass
+
+class bytes:
+    pass
+
+class str:
+    pass
+
+class bool(int):
+    pass
 
 class dict(Mapping[KT, VT]):
     @overload
-    def __init__(self, **kwargs: VT) -> None: pass
+    def __init__(self, **kwargs: VT) -> None:
+        pass
     @overload
-    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: pass
-    def __getitem__(self, key: KT) -> VT: pass
-    def __setitem__(self, k: KT, v: VT) -> None: pass
-    def __iter__(self) -> Iterator[KT]: pass
-    def __contains__(self, item: object) -> int: pass
-    def update(self, a: Mapping[KT, VT]) -> None: pass
+    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None:
+        pass
+    def __getitem__(self, key: KT) -> VT:
+        pass
+    def __setitem__(self, k: KT, v: VT) -> None:
+        pass
+    def __iter__(self) -> Iterator[KT]:
+        pass
+    def __contains__(self, item: object) -> int:
+        pass
+    def update(self, a: Mapping[KT, VT]) -> None:
+        pass
     @overload
-    def get(self, k: KT) -> Optional[VT]: pass
+    def get(self, k: KT) -> Optional[VT]:
+        pass
     @overload
-    def get(self, k: KT, default: Union[KT, _T]) -> Union[VT, _T]: pass
+    def get(self, k: KT, default: Union[KT, _T]) -> Union[VT, _T]:
+        pass
     def __len__(self) -> int: ...
 
 class list(Generic[_T], Sequence[_T]):
-    def __contains__(self, item: object) -> int: pass
-    def __getitem__(self, key: int) -> _T: pass
-    def __iter__(self) -> Iterator[_T]: pass
+    def __contains__(self, item: object) -> int:
+        pass
+    def __getitem__(self, key: int) -> _T:
+        pass
+    def __iter__(self) -> Iterator[_T]:
+        pass
+
+class function:
+    pass
+
+class classmethod:
+    pass
 
-class function: pass
-class classmethod: pass
 property = object()
diff --git a/test-data/unit/fixtures/dict.pyi b/test-data/unit/fixtures/dict.pyi
index 19d175ff7..e790ce9a5 100644
--- a/test-data/unit/fixtures/dict.pyi
+++ b/test-data/unit/fixtures/dict.pyi
@@ -3,64 +3,111 @@
 from _typeshed import SupportsKeysAndGetItem
 import _typeshed
 from typing import (
-    TypeVar, Generic, Iterable, Iterator, Mapping, Tuple, overload, Optional, Union, Sequence
+    TypeVar,
+    Generic,
+    Iterable,
+    Iterator,
+    Mapping,
+    Tuple,
+    overload,
+    Optional,
+    Union,
+    Sequence,
 )
 
-T = TypeVar('T')
-KT = TypeVar('KT')
-VT = TypeVar('VT')
+T = TypeVar("T")
+KT = TypeVar("KT")
+VT = TypeVar("VT")
 
 class object:
-    def __init__(self) -> None: pass
-    def __init_subclass__(cls) -> None: pass
-    def __eq__(self, other: object) -> bool: pass
+    def __init__(self) -> None:
+        pass
+    def __init_subclass__(cls) -> None:
+        pass
+    def __eq__(self, other: object) -> bool:
+        pass
 
 class type:
     __annotations__: Mapping[str, object]
 
 class dict(Mapping[KT, VT]):
     @overload
-    def __init__(self, **kwargs: VT) -> None: pass
+    def __init__(self, **kwargs: VT) -> None:
+        pass
     @overload
-    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: pass
-    def __getitem__(self, key: KT) -> VT: pass
-    def __setitem__(self, k: KT, v: VT) -> None: pass
-    def __iter__(self) -> Iterator[KT]: pass
-    def __contains__(self, item: object) -> int: pass
-    def update(self, a: SupportsKeysAndGetItem[KT, VT]) -> None: pass
+    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None:
+        pass
+    def __getitem__(self, key: KT) -> VT:
+        pass
+    def __setitem__(self, k: KT, v: VT) -> None:
+        pass
+    def __iter__(self) -> Iterator[KT]:
+        pass
+    def __contains__(self, item: object) -> int:
+        pass
+    def update(self, a: SupportsKeysAndGetItem[KT, VT]) -> None:
+        pass
     @overload
-    def get(self, k: KT) -> Optional[VT]: pass
+    def get(self, k: KT) -> Optional[VT]:
+        pass
     @overload
-    def get(self, k: KT, default: Union[VT, T]) -> Union[VT, T]: pass
+    def get(self, k: KT, default: Union[VT, T]) -> Union[VT, T]:
+        pass
     def __len__(self) -> int: ...
 
-class int: # for convenience
-    def __add__(self, x: Union[int, complex]) -> int: pass
-    def __radd__(self, x: int) -> int: pass
-    def __sub__(self, x: Union[int, complex]) -> int: pass
-    def __neg__(self) -> int: pass
+class int:  # for convenience
+    def __add__(self, x: Union[int, complex]) -> int:
+        pass
+    def __radd__(self, x: int) -> int:
+        pass
+    def __sub__(self, x: Union[int, complex]) -> int:
+        pass
+    def __neg__(self) -> int:
+        pass
     real: int
     imag: int
 
-class str: pass # for keyword argument key type
-class bytes: pass
+class str:
+    pass  # for keyword argument key type
 
-class list(Sequence[T]): # needed by some test cases
-    def __getitem__(self, x: int) -> T: pass
-    def __iter__(self) -> Iterator[T]: pass
-    def __mul__(self, x: int) -> list[T]: pass
-    def __contains__(self, item: object) -> bool: pass
-    def append(self, item: T) -> None: pass
+class bytes:
+    pass
 
-class tuple(Generic[T]): pass
-class function: pass
-class float: pass
-class complex: pass
-class bool(int): pass
+class list(Sequence[T]):  # needed by some test cases
+    def __getitem__(self, x: int) -> T:
+        pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __mul__(self, x: int) -> list[T]:
+        pass
+    def __contains__(self, item: object) -> bool:
+        pass
+    def append(self, item: T) -> None:
+        pass
+
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
+class float:
+    pass
+
+class complex:
+    pass
+
+class bool(int):
+    pass
 
 class ellipsis:
     __class__: object
-def isinstance(x: object, t: Union[type, Tuple[type, ...]]) -> bool: pass
-class BaseException: pass
 
-def iter(__iterable: Iterable[T]) -> Iterator[T]: pass
+def isinstance(x: object, t: Union[type, Tuple[type, ...]]) -> bool:
+    pass
+
+class BaseException:
+    pass
+
+def iter(__iterable: Iterable[T]) -> Iterator[T]:
+    pass
diff --git a/test-data/unit/fixtures/divmod.pyi b/test-data/unit/fixtures/divmod.pyi
index 4d81d8fb4..bde371235 100644
--- a/test-data/unit/fixtures/divmod.pyi
+++ b/test-data/unit/fixtures/divmod.pyi
@@ -1,23 +1,39 @@
 from typing import TypeVar, Tuple, SupportsInt
+
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
 
 class int(SupportsInt):
-    def __divmod__(self, other: int) -> Tuple[int, int]: pass
-    def __rdivmod__(self, other: int) -> Tuple[int, int]: pass
+    def __divmod__(self, other: int) -> Tuple[int, int]:
+        pass
+    def __rdivmod__(self, other: int) -> Tuple[int, int]:
+        pass
 
 class float(SupportsInt):
-    def __divmod__(self, other: float) -> Tuple[float, float]: pass
-    def __rdivmod__(self, other: float) -> Tuple[float, float]: pass
+    def __divmod__(self, other: float) -> Tuple[float, float]:
+        pass
+    def __rdivmod__(self, other: float) -> Tuple[float, float]:
+        pass
+
+class tuple:
+    pass
+
+class function:
+    pass
+
+class str:
+    pass
+
+class type:
+    pass
 
+class ellipsis:
+    pass
 
-class tuple: pass
-class function: pass
-class str: pass
-class type: pass
-class ellipsis: pass
+_N = TypeVar("_N", int, float)
 
-_N = TypeVar('_N', int, float)
 def divmod(_x: _N, _y: _N) -> Tuple[_N, _N]: ...
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/exception.pyi b/test-data/unit/fixtures/exception.pyi
index 08496e4e5..9356f1041 100644
--- a/test-data/unit/fixtures/exception.pyi
+++ b/test-data/unit/fixtures/exception.pyi
@@ -1,29 +1,54 @@
 import sys
 from typing import Generic, TypeVar
-T = TypeVar('T')
+
+T = TypeVar("T")
 
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
+
+class type:
+    pass
 
-class type: pass
 class tuple(Generic[T]):
     def __ge__(self, other: object) -> bool: ...
-class list: pass
-class dict: pass
-class function: pass
-class int: pass
-class str: pass
-class bool: pass
-class ellipsis: pass
+
+class list:
+    pass
+
+class dict:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class bool:
+    pass
+
+class ellipsis:
+    pass
 
 class BaseException:
     def __init__(self, *args: object) -> None: ...
-class Exception(BaseException): pass
-class RuntimeError(Exception): pass
-class NotImplementedError(RuntimeError): pass
+
+class Exception(BaseException):
+    pass
+
+class RuntimeError(Exception):
+    pass
+
+class NotImplementedError(RuntimeError):
+    pass
 
 if sys.version_info >= (3, 11):
     _BT_co = TypeVar("_BT_co", bound=BaseException, covariant=True)
     _T_co = TypeVar("_T_co", bound=Exception, covariant=True)
+
     class BaseExceptionGroup(BaseException, Generic[_BT_co]): ...
     class ExceptionGroup(BaseExceptionGroup[_T_co], Exception): ...
diff --git a/test-data/unit/fixtures/f_string.pyi b/test-data/unit/fixtures/f_string.pyi
index 328c666b7..6ef83262f 100644
--- a/test-data/unit/fixtures/f_string.pyi
+++ b/test-data/unit/fixtures/f_string.pyi
@@ -3,36 +3,52 @@
 
 from typing import TypeVar, Generic, Iterable, Iterator, List, overload
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
-class ellipsis: pass
+class ellipsis:
+    pass
 
 class list(Iterable[T], Generic[T]):
     @overload
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
     @overload
-    def __init__(self, x: Iterable[T]) -> None: pass
-    def append(self, x: T) -> None: pass
+    def __init__(self, x: Iterable[T]) -> None:
+        pass
+    def append(self, x: T) -> None:
+        pass
 
-class tuple(Generic[T]): pass
+class tuple(Generic[T]):
+    pass
 
-class function: pass
-class int:
-    def __add__(self, i: int) -> int: pass
+class function:
+    pass
 
-class float: pass
-class bool(int): pass
+class int:
+    def __add__(self, i: int) -> int:
+        pass
 
-class str:
-    def __add__(self, s: str) -> str: pass
-    def format(self, *args) -> str: pass
-    def join(self, l: List[str]) -> str: pass
+class float:
+    pass
 
+class bool(int):
+    pass
 
-class dict: pass
+class str:
+    def __add__(self, s: str) -> str:
+        pass
+    def format(self, *args) -> str:
+        pass
+    def join(self, l: List[str]) -> str:
+        pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/fine_grained.pyi b/test-data/unit/fixtures/fine_grained.pyi
index e454a27a5..4ec55540e 100644
--- a/test-data/unit/fixtures/fine_grained.pyi
+++ b/test-data/unit/fixtures/fine_grained.pyi
@@ -6,25 +6,44 @@
 import types
 from typing import TypeVar, Generic
 
-T = TypeVar('T')
+T = TypeVar("T")
 
-class Any: pass
+class Any:
+    pass
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x: Any) -> None: pass
+    def __init__(self, x: Any) -> None:
+        pass
 
 class int:
-    def __add__(self, other: 'int') -> 'int': pass
+    def __add__(self, other: "int") -> "int":
+        pass
+
 class str:
-    def __add__(self, other: 'str') -> 'str': pass
-
-class float: pass
-class bytes: pass
-class tuple(Generic[T]): pass
-class function: pass
-class ellipsis: pass
-class list(Generic[T]): pass
-class dict: pass
+    def __add__(self, other: "str") -> "str":
+        pass
+
+class float:
+    pass
+
+class bytes:
+    pass
+
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
+class ellipsis:
+    pass
+
+class list(Generic[T]):
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/float.pyi b/test-data/unit/fixtures/float.pyi
index 5db452584..ce32a3e62 100644
--- a/test-data/unit/fixtures/float.pyi
+++ b/test-data/unit/fixtures/float.pyi
@@ -1,25 +1,33 @@
 from typing import Generic, TypeVar
-T = TypeVar('T')
+
+T = TypeVar("T")
 
 Any = 0
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x: Any) -> None: pass
+    def __init__(self, x: Any) -> None:
+        pass
 
 class str:
-    def __add__(self, other: 'str') -> 'str': pass
+    def __add__(self, other: "str") -> "str":
+        pass
     def __rmul__(self, n: int) -> str: ...
 
-class bytes: pass
+class bytes:
+    pass
 
-class tuple(Generic[T]): pass
-class function: pass
+class tuple(Generic[T]):
+    pass
 
-class ellipsis: pass
+class function:
+    pass
 
+class ellipsis:
+    pass
 
 class int:
     def __abs__(self) -> int: ...
@@ -35,4 +43,5 @@ class float:
     def __mul__(self, x: float) -> float: ...
     def __rmul__(self, x: float) -> float: ...
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/floatdict.pyi b/test-data/unit/fixtures/floatdict.pyi
index 7baa7ca92..7e3db78ff 100644
--- a/test-data/unit/fixtures/floatdict.pyi
+++ b/test-data/unit/fixtures/floatdict.pyi
@@ -1,55 +1,80 @@
 from typing import TypeVar, Generic, Iterable, Iterator, Mapping, Tuple, overload, Optional, Union
 
-T = TypeVar('T')
-KT = TypeVar('KT')
-VT = TypeVar('VT')
+T = TypeVar("T")
+KT = TypeVar("KT")
+VT = TypeVar("VT")
 
 Any = 0
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x: Any) -> None: pass
+    def __init__(self, x: Any) -> None:
+        pass
 
 class str:
-    def __add__(self, other: 'str') -> 'str': pass
+    def __add__(self, other: "str") -> "str":
+        pass
     def __rmul__(self, n: int) -> str: ...
 
-class bytes: pass
+class bytes:
+    pass
 
-class tuple(Generic[T]): pass
-class slice: pass
-class function: pass
+class tuple(Generic[T]):
+    pass
 
-class ellipsis: pass
+class slice:
+    pass
+
+class function:
+    pass
+
+class ellipsis:
+    pass
 
 class list(Iterable[T], Generic[T]):
     @overload
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
     @overload
-    def __init__(self, x: Iterable[T]) -> None: pass
-    def __iter__(self) -> Iterator[T]: pass
-    def __add__(self, x: list[T]) -> list[T]: pass
-    def __mul__(self, x: int) -> list[T]: pass
-    def __getitem__(self, x: int) -> T: pass
-    def append(self, x: T) -> None: pass
-    def extend(self, x: Iterable[T]) -> None: pass
+    def __init__(self, x: Iterable[T]) -> None:
+        pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __add__(self, x: list[T]) -> list[T]:
+        pass
+    def __mul__(self, x: int) -> list[T]:
+        pass
+    def __getitem__(self, x: int) -> T:
+        pass
+    def append(self, x: T) -> None:
+        pass
+    def extend(self, x: Iterable[T]) -> None:
+        pass
 
 class dict(Mapping[KT, VT], Generic[KT, VT]):
     @overload
-    def __init__(self, **kwargs: VT) -> None: pass
+    def __init__(self, **kwargs: VT) -> None:
+        pass
     @overload
-    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: pass
-    def __setitem__(self, k: KT, v: VT) -> None: pass
-    def __getitem__(self, k: KT) -> VT: pass
-    def __iter__(self) -> Iterator[KT]: pass
-    def update(self, a: Mapping[KT, VT]) -> None: pass
+    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None:
+        pass
+    def __setitem__(self, k: KT, v: VT) -> None:
+        pass
+    def __getitem__(self, k: KT) -> VT:
+        pass
+    def __iter__(self) -> Iterator[KT]:
+        pass
+    def update(self, a: Mapping[KT, VT]) -> None:
+        pass
     @overload
-    def get(self, k: KT) -> Optional[VT]: pass
+    def get(self, k: KT) -> Optional[VT]:
+        pass
     @overload
-    def get(self, k: KT, default: Union[KT, T]) -> Union[VT, T]: pass
-
+    def get(self, k: KT, default: Union[KT, T]) -> Union[VT, T]:
+        pass
 
 class int:
     def __float__(self) -> float: ...
diff --git a/test-data/unit/fixtures/for.pyi b/test-data/unit/fixtures/for.pyi
index 694f83e94..cae3d9ee4 100644
--- a/test-data/unit/fixtures/for.pyi
+++ b/test-data/unit/fixtures/for.pyi
@@ -3,19 +3,34 @@
 from typing import TypeVar, Generic, Iterable, Iterator, Generator
 from abc import abstractmethod, ABCMeta
 
-t = TypeVar('t')
+t = TypeVar("t")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
+class type:
+    pass
 
-class type: pass
 class tuple(Generic[t]):
-    def __iter__(self) -> Iterator[t]: pass
-class function: pass
-class bool: pass
-class int: pass # for convenience
-class str: pass # for convenience
+    def __iter__(self) -> Iterator[t]:
+        pass
+
+class function:
+    pass
+
+class bool:
+    pass
+
+class int:
+    pass  # for convenience
+
+class str:
+    pass  # for convenience
 
 class list(Iterable[t], Generic[t]):
-    def __iter__(self) -> Iterator[t]: pass
-class dict: pass
+    def __iter__(self) -> Iterator[t]:
+        pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/function.pyi b/test-data/unit/fixtures/function.pyi
index 697d0d919..b4980213b 100644
--- a/test-data/unit/fixtures/function.pyi
+++ b/test-data/unit/fixtures/function.pyi
@@ -1,8 +1,18 @@
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
 
-class type: pass
-class function: pass
-class int: pass
-class str: pass
-class dict: pass
+class type:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/isinstance.pyi b/test-data/unit/fixtures/isinstance.pyi
index c1125c24b..b606695c5 100644
--- a/test-data/unit/fixtures/isinstance.pyi
+++ b/test-data/unit/fixtures/isinstance.pyi
@@ -1,29 +1,48 @@
 from typing import Tuple, TypeVar, Generic, Union, cast, Any, Type
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
-class tuple(Generic[T]): pass
+class tuple(Generic[T]):
+    pass
 
-class function: pass
+class function:
+    pass
 
-def isinstance(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool: pass
-def issubclass(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool: pass
-def hasattr(x: object, name: str) -> bool: pass
+def isinstance(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool:
+    pass
+
+def issubclass(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool:
+    pass
+
+def hasattr(x: object, name: str) -> bool:
+    pass
 
 class int:
-    def __add__(self, other: 'int') -> 'int': pass
-class float: pass
-class bool(int): pass
+    def __add__(self, other: "int") -> "int":
+        pass
+
+class float:
+    pass
+
+class bool(int):
+    pass
+
 class str:
-    def __add__(self, other: 'str') -> 'str': pass
-class ellipsis: pass
+    def __add__(self, other: "str") -> "str":
+        pass
+
+class ellipsis:
+    pass
 
 NotImplemented = cast(Any, None)
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/isinstance_python3_10.pyi b/test-data/unit/fixtures/isinstance_python3_10.pyi
index 7c919a216..1aaab1222 100644
--- a/test-data/unit/fixtures/isinstance_python3_10.pyi
+++ b/test-data/unit/fixtures/isinstance_python3_10.pyi
@@ -2,30 +2,48 @@
 from typing import Tuple, TypeVar, Generic, Union, cast, Any, Type
 import types
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type(Generic[T]):
-    def __init__(self, x) -> None: pass
-    def __or__(self, x) -> types.Union: pass
+    def __init__(self, x) -> None:
+        pass
+    def __or__(self, x) -> types.Union:
+        pass
 
-class tuple(Generic[T]): pass
+class tuple(Generic[T]):
+    pass
 
-class function: pass
+class function:
+    pass
 
-def isinstance(x: object, t: Union[Type[object], Tuple[Type[object], ...], types.Union]) -> bool: pass
-def issubclass(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool: pass
+def isinstance(x: object, t: Union[Type[object], Tuple[Type[object], ...], types.Union]) -> bool:
+    pass
+
+def issubclass(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool:
+    pass
 
 class int:
-    def __add__(self, other: 'int') -> 'int': pass
-class float: pass
-class bool(int): pass
+    def __add__(self, other: "int") -> "int":
+        pass
+
+class float:
+    pass
+
+class bool(int):
+    pass
+
 class str:
-    def __add__(self, other: 'str') -> 'str': pass
-class ellipsis: pass
+    def __add__(self, other: "str") -> "str":
+        pass
+
+class ellipsis:
+    pass
 
 NotImplemented = cast(Any, None)
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/isinstancelist.pyi b/test-data/unit/fixtures/isinstancelist.pyi
index 0ee5258ff..c623e7b19 100644
--- a/test-data/unit/fixtures/isinstancelist.pyi
+++ b/test-data/unit/fixtures/isinstancelist.pyi
@@ -1,61 +1,109 @@
 from typing import (
-    Iterable, Iterator, TypeVar, List, Mapping, overload, Tuple, Set, Union, Generic, Sequence
+    Iterable,
+    Iterator,
+    TypeVar,
+    List,
+    Mapping,
+    overload,
+    Tuple,
+    Set,
+    Union,
+    Generic,
+    Sequence,
 )
 
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, other: object) -> bool: pass
+    def __init__(self) -> None:
+        pass
+    def __eq__(self, other: object) -> bool:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
-class function: pass
-class classmethod: pass
+class function:
+    pass
+
+class classmethod:
+    pass
+
+class ellipsis:
+    pass
 
-class ellipsis: pass
 EllipsisType = ellipsis
 Ellipsis = ellipsis()
 
-def isinstance(x: object, t: Union[type, Tuple]) -> bool: pass
-def issubclass(x: object, t: Union[type, Tuple]) -> bool: pass
+def isinstance(x: object, t: Union[type, Tuple]) -> bool:
+    pass
+
+def issubclass(x: object, t: Union[type, Tuple]) -> bool:
+    pass
 
 class int:
-    def __add__(self, x: int) -> int: pass
-class float: pass
-class bool(int): pass
+    def __add__(self, x: int) -> int:
+        pass
+
+class float:
+    pass
+
+class bool(int):
+    pass
+
 class str:
-    def __add__(self, x: str) -> str: pass
-    def __getitem__(self, x: int) -> str: pass
+    def __add__(self, x: str) -> str:
+        pass
+    def __getitem__(self, x: int) -> str:
+        pass
 
-T = TypeVar('T')
-KT = TypeVar('KT')
-VT = TypeVar('VT')
+T = TypeVar("T")
+KT = TypeVar("KT")
+VT = TypeVar("VT")
 
 class tuple(Generic[T]):
-    def __len__(self) -> int: pass
+    def __len__(self) -> int:
+        pass
 
 class list(Sequence[T]):
-    def __iter__(self) -> Iterator[T]: pass
-    def __mul__(self, x: int) -> list[T]: pass
-    def __setitem__(self, x: int, v: T) -> None: pass
-    def __getitem__(self, x: int) -> T: pass
-    def __add__(self, x: List[T]) -> T: pass
-    def __contains__(self, item: object) -> bool: pass
-    def append(self, x: T) -> None: pass
-    def extend(self, x: Iterable[T]) -> None: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __mul__(self, x: int) -> list[T]:
+        pass
+    def __setitem__(self, x: int, v: T) -> None:
+        pass
+    def __getitem__(self, x: int) -> T:
+        pass
+    def __add__(self, x: List[T]) -> T:
+        pass
+    def __contains__(self, item: object) -> bool:
+        pass
+    def append(self, x: T) -> None:
+        pass
+    def extend(self, x: Iterable[T]) -> None:
+        pass
 
 class dict(Mapping[KT, VT]):
     @overload
-    def __init__(self, **kwargs: VT) -> None: pass
+    def __init__(self, **kwargs: VT) -> None:
+        pass
     @overload
-    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: pass
-    def __setitem__(self, k: KT, v: VT) -> None: pass
-    def __iter__(self) -> Iterator[KT]: pass
-    def update(self, a: Mapping[KT, VT]) -> None: pass
+    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None:
+        pass
+    def __setitem__(self, k: KT, v: VT) -> None:
+        pass
+    def __iter__(self) -> Iterator[KT]:
+        pass
+    def update(self, a: Mapping[KT, VT]) -> None:
+        pass
 
 class set(Generic[T]):
-    def __iter__(self) -> Iterator[T]: pass
-    def add(self, x: T) -> None: pass
-    def discard(self, x: T) -> None: pass
-    def update(self, x: Set[T]) -> None: pass
-    def pop(self) -> T: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def add(self, x: T) -> None:
+        pass
+    def discard(self, x: T) -> None:
+        pass
+    def update(self, x: Set[T]) -> None:
+        pass
+    def pop(self) -> T:
+        pass
diff --git a/test-data/unit/fixtures/list.pyi b/test-data/unit/fixtures/list.pyi
index 90fbabe8b..58284e2f6 100644
--- a/test-data/unit/fixtures/list.pyi
+++ b/test-data/unit/fixtures/list.pyi
@@ -2,39 +2,66 @@
 
 from typing import TypeVar, Generic, Iterable, Iterator, Sequence, overload
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
-class type: pass
-class ellipsis: pass
+class type:
+    pass
+
+class ellipsis:
+    pass
 
 class list(Sequence[T]):
     @overload
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
     @overload
-    def __init__(self, x: Iterable[T]) -> None: pass
-    def __iter__(self) -> Iterator[T]: pass
-    def __len__(self) -> int: pass
-    def __contains__(self, item: object) -> bool: pass
-    def __add__(self, x: list[T]) -> list[T]: pass
-    def __mul__(self, x: int) -> list[T]: pass
-    def __getitem__(self, x: int) -> T: pass
-    def __setitem__(self, x: int, v: T) -> None: pass
-    def append(self, x: T) -> None: pass
-    def extend(self, x: Iterable[T]) -> None: pass
-
-class tuple(Generic[T]): pass
-class function: pass
+    def __init__(self, x: Iterable[T]) -> None:
+        pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __len__(self) -> int:
+        pass
+    def __contains__(self, item: object) -> bool:
+        pass
+    def __add__(self, x: list[T]) -> list[T]:
+        pass
+    def __mul__(self, x: int) -> list[T]:
+        pass
+    def __getitem__(self, x: int) -> T:
+        pass
+    def __setitem__(self, x: int, v: T) -> None:
+        pass
+    def append(self, x: T) -> None:
+        pass
+    def extend(self, x: Iterable[T]) -> None:
+        pass
+
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
 class int:
-    def __bool__(self) -> bool: pass
+    def __bool__(self) -> bool:
+        pass
+
 class float:
-    def __bool__(self) -> bool: pass
+    def __bool__(self) -> bool:
+        pass
+
 class str:
-    def __len__(self) -> bool: pass
-class bool(int): pass
+    def __len__(self) -> bool:
+        pass
+
+class bool(int):
+    pass
 
-property = object() # Dummy definition.
+property = object()  # Dummy definition.
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/module.pyi b/test-data/unit/fixtures/module.pyi
index 47408befd..636fff1c5 100644
--- a/test-data/unit/fixtures/module.pyi
+++ b/test-data/unit/fixtures/module.pyi
@@ -1,23 +1,43 @@
 from typing import Any, Dict, Generic, TypeVar, Sequence
 from types import ModuleType
 
-T = TypeVar('T')
-S = TypeVar('S')
+T = TypeVar("T")
+S = TypeVar("S")
 
-class list(Generic[T], Sequence[T]): pass
+class list(Generic[T], Sequence[T]):
+    pass
 
 class object:
-    def __init__(self) -> None: pass
-class type: pass
-class function: pass
-class int: pass
-class str: pass
-class bool: pass
-class tuple(Generic[T]): pass
-class dict(Generic[T, S]): pass
-class ellipsis: pass
+    def __init__(self) -> None:
+        pass
+
+class type:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class bool:
+    pass
+
+class tuple(Generic[T]):
+    pass
+
+class dict(Generic[T, S]):
+    pass
+
+class ellipsis:
+    pass
 
 classmethod = object()
 staticmethod = object()
 property = object()
-def hasattr(x: object, name: str) -> bool: pass
+
+def hasattr(x: object, name: str) -> bool:
+    pass
diff --git a/test-data/unit/fixtures/module_all.pyi b/test-data/unit/fixtures/module_all.pyi
index b14152c7e..076b95f40 100644
--- a/test-data/unit/fixtures/module_all.pyi
+++ b/test-data/unit/fixtures/module_all.pyi
@@ -1,19 +1,40 @@
 from typing import Generic, Sequence, TypeVar
 from types import ModuleType
 
-_T = TypeVar('_T')
+_T = TypeVar("_T")
 
 class object:
-    def __init__(self) -> None: pass
-class type: pass
-class function: pass
-class int: pass
-class str: pass
-class bool: pass
+    def __init__(self) -> None:
+        pass
+
+class type:
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class bool:
+    pass
+
 class list(Generic[_T], Sequence[_T]):
-    def append(self, x: _T): pass
-    def extend(self, x: Sequence[_T]): pass
-    def __add__(self, rhs: Sequence[_T]) -> list[_T]: pass
-class tuple(Generic[_T]): pass
-class ellipsis: pass
-class dict: pass
+    def append(self, x: _T):
+        pass
+    def extend(self, x: Sequence[_T]):
+        pass
+    def __add__(self, rhs: Sequence[_T]) -> list[_T]:
+        pass
+
+class tuple(Generic[_T]):
+    pass
+
+class ellipsis:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/narrowing.pyi b/test-data/unit/fixtures/narrowing.pyi
index 89ee011c1..5a4fd1fde 100644
--- a/test-data/unit/fixtures/narrowing.pyi
+++ b/test-data/unit/fixtures/narrowing.pyi
@@ -1,20 +1,34 @@
 # Builtins stub used in check-narrowing test cases.
 from typing import Generic, Sequence, Tuple, Type, TypeVar, Union
 
-
-Tco = TypeVar('Tco', covariant=True)
+Tco = TypeVar("Tco", covariant=True)
 KT = TypeVar("KT")
 VT = TypeVar("VT")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
+class type:
+    pass
+
+class tuple(Sequence[Tco], Generic[Tco]):
+    pass
+
+class function:
+    pass
+
+class ellipsis:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
 
-class type: pass
-class tuple(Sequence[Tco], Generic[Tco]): pass
-class function: pass
-class ellipsis: pass
-class int: pass
-class str: pass
-class dict(Generic[KT, VT]): pass
+class dict(Generic[KT, VT]):
+    pass
 
-def isinstance(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool: pass
+def isinstance(x: object, t: Union[Type[object], Tuple[Type[object], ...]]) -> bool:
+    pass
diff --git a/test-data/unit/fixtures/notimplemented.pyi b/test-data/unit/fixtures/notimplemented.pyi
index 2ca376ea0..3cf9c9a04 100644
--- a/test-data/unit/fixtures/notimplemented.pyi
+++ b/test-data/unit/fixtures/notimplemented.pyi
@@ -1,14 +1,26 @@
 # builtins stub used in NotImplemented related cases.
 from typing import Any, cast
 
-
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
+
+class type:
+    pass
+
+class function:
+    pass
+
+class bool:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
 
-class type: pass
-class function: pass
-class bool: pass
-class int: pass
-class str: pass
 NotImplemented = cast(Any, None)
-class dict: pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/object_hashable.pyi b/test-data/unit/fixtures/object_hashable.pyi
index 49b17991f..adedf32e5 100644
--- a/test-data/unit/fixtures/object_hashable.pyi
+++ b/test-data/unit/fixtures/object_hashable.pyi
@@ -7,4 +7,6 @@ class float: ...
 class str: ...
 class ellipsis: ...
 class tuple: ...
-class dict: pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/object_with_init_subclass.pyi b/test-data/unit/fixtures/object_with_init_subclass.pyi
index da062349a..29c1e52ae 100644
--- a/test-data/unit/fixtures/object_with_init_subclass.pyi
+++ b/test-data/unit/fixtures/object_with_init_subclass.pyi
@@ -1,61 +1,116 @@
-from typing import Sequence, Iterator, TypeVar, Mapping, Iterable, Optional, Union, overload, Tuple, Generic, List
+from typing import (
+    Sequence,
+    Iterator,
+    TypeVar,
+    Mapping,
+    Iterable,
+    Optional,
+    Union,
+    overload,
+    Tuple,
+    Generic,
+    List,
+)
 
 class object:
     def __init__(self) -> None: ...
     def __init_subclass__(cls) -> None: ...
 
-T = TypeVar('T')
-KT = TypeVar('KT')
-VT = TypeVar('VT')
+T = TypeVar("T")
+KT = TypeVar("KT")
+VT = TypeVar("VT")
+
 # copy pasted from primitives.pyi
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
 class int:
     # Note: this is a simplification of the actual signature
-    def __init__(self, x: object = ..., base: int = ...) -> None: pass
-    def __add__(self, i: int) -> int: pass
+    def __init__(self, x: object = ..., base: int = ...) -> None:
+        pass
+    def __add__(self, i: int) -> int:
+        pass
+
 class float:
-    def __float__(self) -> float: pass
-class complex: pass
-class bool(int): pass
+    def __float__(self) -> float:
+        pass
+
+class complex:
+    pass
+
+class bool(int):
+    pass
+
 class str(Sequence[str]):
-    def __add__(self, s: str) -> str: pass
-    def __iter__(self) -> Iterator[str]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> str: pass
-    def format(self, *args) -> str: pass
+    def __add__(self, s: str) -> str:
+        pass
+    def __iter__(self) -> Iterator[str]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> str:
+        pass
+    def format(self, *args) -> str:
+        pass
+
 class bytes(Sequence[int]):
-    def __iter__(self) -> Iterator[int]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> int: pass
-class bytearray: pass
-class tuple(Generic[T]): pass
-class function: pass
-class ellipsis: pass
+    def __iter__(self) -> Iterator[int]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> int:
+        pass
+
+class bytearray:
+    pass
+
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
+class ellipsis:
+    pass
 
 # copy-pasted from list.pyi
 class list(Sequence[T]):
-    def __iter__(self) -> Iterator[T]: pass
-    def __mul__(self, x: int) -> list[T]: pass
-    def __setitem__(self, x: int, v: T) -> None: pass
-    def __getitem__(self, x: int) -> T: pass
-    def __add__(self, x: List[T]) -> T: pass
-    def __contains__(self, item: object) -> bool: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __mul__(self, x: int) -> list[T]:
+        pass
+    def __setitem__(self, x: int, v: T) -> None:
+        pass
+    def __getitem__(self, x: int) -> T:
+        pass
+    def __add__(self, x: List[T]) -> T:
+        pass
+    def __contains__(self, item: object) -> bool:
+        pass
 
 # copy-pasted from dict.pyi
 class dict(Mapping[KT, VT]):
     @overload
-    def __init__(self, **kwargs: VT) -> None: pass
+    def __init__(self, **kwargs: VT) -> None:
+        pass
     @overload
-    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None: pass
-    def __getitem__(self, key: KT) -> VT: pass
-    def __setitem__(self, k: KT, v: VT) -> None: pass
-    def __iter__(self) -> Iterator[KT]: pass
-    def __contains__(self, item: object) -> int: pass
-    def update(self, a: Mapping[KT, VT]) -> None: pass
+    def __init__(self, arg: Iterable[Tuple[KT, VT]], **kwargs: VT) -> None:
+        pass
+    def __getitem__(self, key: KT) -> VT:
+        pass
+    def __setitem__(self, k: KT, v: VT) -> None:
+        pass
+    def __iter__(self) -> Iterator[KT]:
+        pass
+    def __contains__(self, item: object) -> int:
+        pass
+    def update(self, a: Mapping[KT, VT]) -> None:
+        pass
     @overload
-    def get(self, k: KT) -> Optional[VT]: pass
+    def get(self, k: KT) -> Optional[VT]:
+        pass
     @overload
-    def get(self, k: KT, default: Union[KT, T]) -> Union[VT, T]: pass
+    def get(self, k: KT, default: Union[KT, T]) -> Union[VT, T]:
+        pass
     def __len__(self) -> int: ...
diff --git a/test-data/unit/fixtures/ops.pyi b/test-data/unit/fixtures/ops.pyi
index 9cc4d22eb..936c8fe9d 100644
--- a/test-data/unit/fixtures/ops.pyi
+++ b/test-data/unit/fixtures/ops.pyi
@@ -1,76 +1,125 @@
 from typing import overload, Any, Generic, Sequence, Tuple, TypeVar, Optional
 
-Tco = TypeVar('Tco', covariant=True)
+Tco = TypeVar("Tco", covariant=True)
 
 # This is an extension of transform builtins with additional operations.
 
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, o: 'object') -> 'bool': pass
-    def __ne__(self, o: 'object') -> 'bool': pass
+    def __init__(self) -> None:
+        pass
+    def __eq__(self, o: "object") -> "bool":
+        pass
+    def __ne__(self, o: "object") -> "bool":
+        pass
 
-class type: pass
+class type:
+    pass
 
-class slice: pass
+class slice:
+    pass
 
 class tuple(Sequence[Tco]):
-    def __getitem__(self, x: int) -> Tco: pass
-    def __eq__(self, x: object) -> bool: pass
-    def __ne__(self, x: object) -> bool: pass
-    def __lt__(self, x: Tuple[Tco, ...]) -> bool: pass
-    def __le__(self, x: Tuple[Tco, ...]) -> bool: pass
-    def __gt__(self, x: Tuple[Tco, ...]) -> bool: pass
-    def __ge__(self, x: Tuple[Tco, ...]) -> bool: pass
-
-class function: pass
-
-class bool: pass
+    def __getitem__(self, x: int) -> Tco:
+        pass
+    def __eq__(self, x: object) -> bool:
+        pass
+    def __ne__(self, x: object) -> bool:
+        pass
+    def __lt__(self, x: Tuple[Tco, ...]) -> bool:
+        pass
+    def __le__(self, x: Tuple[Tco, ...]) -> bool:
+        pass
+    def __gt__(self, x: Tuple[Tco, ...]) -> bool:
+        pass
+    def __ge__(self, x: Tuple[Tco, ...]) -> bool:
+        pass
+
+class function:
+    pass
+
+class bool:
+    pass
 
 class str:
-    def __init__(self, x: 'int') -> None: pass
-    def __add__(self, x: 'str') -> 'str': pass
-    def __eq__(self, x: object) -> bool: pass
-    def startswith(self, x: 'str') -> bool: pass
-    def strip(self) -> 'str': pass
+    def __init__(self, x: "int") -> None:
+        pass
+    def __add__(self, x: "str") -> "str":
+        pass
+    def __eq__(self, x: object) -> bool:
+        pass
+    def startswith(self, x: "str") -> bool:
+        pass
+    def strip(self) -> "str":
+        pass
 
 class int:
-    def __add__(self, x: 'int') -> 'int': pass
-    def __radd__(self, x: 'int') -> 'int': pass
-    def __sub__(self, x: 'int') -> 'int': pass
-    def __mul__(self, x: 'int') -> 'int': pass
-    def __div__(self, x: 'int') -> 'int': pass
-    def __rdiv__(self, x: 'int') -> 'int': pass
-    def __truediv__(self, x: 'int') -> 'int': pass
-    def __rtruediv__(self, x: 'int') -> 'int': pass
-    def __mod__(self, x: 'int') -> 'int': pass
-    def __floordiv__(self, x: 'int') -> 'int': pass
-    def __pow__(self, x: 'int', __modulo: Optional[int] = ...) -> Any: pass
-    def __pos__(self) -> 'int': pass
-    def __neg__(self) -> 'int': pass
-    def __eq__(self, x: object) -> bool: pass
-    def __ne__(self, x: object) -> bool: pass
-    def __lt__(self, x: 'int') -> bool: pass
-    def __le__(self, x: 'int') -> bool: pass
-    def __gt__(self, x: 'int') -> bool: pass
-    def __ge__(self, x: 'int') -> bool: pass
+    def __add__(self, x: "int") -> "int":
+        pass
+    def __radd__(self, x: "int") -> "int":
+        pass
+    def __sub__(self, x: "int") -> "int":
+        pass
+    def __mul__(self, x: "int") -> "int":
+        pass
+    def __div__(self, x: "int") -> "int":
+        pass
+    def __rdiv__(self, x: "int") -> "int":
+        pass
+    def __truediv__(self, x: "int") -> "int":
+        pass
+    def __rtruediv__(self, x: "int") -> "int":
+        pass
+    def __mod__(self, x: "int") -> "int":
+        pass
+    def __floordiv__(self, x: "int") -> "int":
+        pass
+    def __pow__(self, x: "int", __modulo: Optional[int] = ...) -> Any:
+        pass
+    def __pos__(self) -> "int":
+        pass
+    def __neg__(self) -> "int":
+        pass
+    def __eq__(self, x: object) -> bool:
+        pass
+    def __ne__(self, x: object) -> bool:
+        pass
+    def __lt__(self, x: "int") -> bool:
+        pass
+    def __le__(self, x: "int") -> bool:
+        pass
+    def __gt__(self, x: "int") -> bool:
+        pass
+    def __ge__(self, x: "int") -> bool:
+        pass
 
 class float:
-    def __add__(self, x: 'float') -> 'float': pass
-    def __radd__(self, x: 'float') -> 'float': pass
-    def __div__(self, x: 'float') -> 'float': pass
-    def __rdiv__(self, x: 'float') -> 'float': pass
-    def __truediv__(self, x: 'float') -> 'float': pass
-    def __rtruediv__(self, x: 'float') -> 'float': pass
+    def __add__(self, x: "float") -> "float":
+        pass
+    def __radd__(self, x: "float") -> "float":
+        pass
+    def __div__(self, x: "float") -> "float":
+        pass
+    def __rdiv__(self, x: "float") -> "float":
+        pass
+    def __truediv__(self, x: "float") -> "float":
+        pass
+    def __rtruediv__(self, x: "float") -> "float":
+        pass
 
 class complex:
-    def __add__(self, x: complex) -> complex: pass
-    def __radd__(self, x: complex) -> complex: pass
+    def __add__(self, x: complex) -> complex:
+        pass
+    def __radd__(self, x: complex) -> complex:
+        pass
 
-class BaseException: pass
+class BaseException:
+    pass
 
-def __print(a1: object = None, a2: object = None, a3: object = None,
-            a4: object = None) -> None: pass
+def __print(a1: object = None, a2: object = None, a3: object = None, a4: object = None) -> None:
+    pass
 
-class ellipsis: pass
+class ellipsis:
+    pass
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/paramspec.pyi b/test-data/unit/fixtures/paramspec.pyi
index 5e4b8564e..e8d649f73 100644
--- a/test-data/unit/fixtures/paramspec.pyi
+++ b/test-data/unit/fixtures/paramspec.pyi
@@ -2,12 +2,22 @@
 
 import _typeshed
 from typing import (
-    Sequence, Generic, TypeVar, Iterable, Iterator, Tuple, Mapping, Optional, Union, Type, overload,
-    Protocol
+    Sequence,
+    Generic,
+    TypeVar,
+    Iterable,
+    Iterator,
+    Tuple,
+    Mapping,
+    Optional,
+    Union,
+    Type,
+    overload,
+    Protocol,
 )
 
 T = TypeVar("T")
-T_co = TypeVar('T_co', covariant=True)
+T_co = TypeVar("T_co", covariant=True)
 KT = TypeVar("KT")
 VT = TypeVar("VT")
 
@@ -30,7 +40,7 @@ class list(Sequence[T], Generic[T]):
     def __iter__(self) -> Iterator[T]: ...
 
 class int:
-    def __neg__(self) -> 'int': ...
+    def __neg__(self) -> "int": ...
 
 class bool(int): ...
 class float: ...
diff --git a/test-data/unit/fixtures/plugin_attrs.pyi b/test-data/unit/fixtures/plugin_attrs.pyi
index f62104809..7edf81954 100644
--- a/test-data/unit/fixtures/plugin_attrs.pyi
+++ b/test-data/unit/fixtures/plugin_attrs.pyi
@@ -2,28 +2,51 @@
 from typing import Union, overload
 
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, o: object) -> bool: pass
-    def __ne__(self, o: object) -> bool: pass
-
-class type: pass
-class bytes: pass
-class function: pass
-class float: pass
+    def __init__(self) -> None:
+        pass
+    def __eq__(self, o: object) -> bool:
+        pass
+    def __ne__(self, o: object) -> bool:
+        pass
+
+class type:
+    pass
+
+class bytes:
+    pass
+
+class function:
+    pass
+
+class float:
+    pass
+
 class int:
     @overload
     def __init__(self, x: Union[str, bytes, int] = ...) -> None: ...
     @overload
     def __init__(self, x: Union[str, bytes], base: int) -> None: ...
-class bool(int): pass
+
+class bool(int):
+    pass
+
 class complex:
     @overload
     def __init__(self, real: float = ..., im: float = ...) -> None: ...
     @overload
     def __init__(self, real: str = ...) -> None: ...
 
-class str: pass
-class ellipsis: pass
-class tuple: pass
-class list: pass
-class dict: pass
+class str:
+    pass
+
+class ellipsis:
+    pass
+
+class tuple:
+    pass
+
+class list:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/primitives.pyi b/test-data/unit/fixtures/primitives.pyi
index b74252857..d7f836de1 100644
--- a/test-data/unit/fixtures/primitives.pyi
+++ b/test-data/unit/fixtures/primitives.pyi
@@ -2,69 +2,127 @@
 import _typeshed
 from typing import Generic, TypeVar, Sequence, Iterator, Mapping, Iterable, Tuple, Union
 
-T = TypeVar('T')
-V = TypeVar('V')
+T = TypeVar("T")
+V = TypeVar("V")
 
 class object:
-    def __init__(self) -> None: pass
-    def __str__(self) -> str: pass
-    def __eq__(self, other: object) -> bool: pass
-    def __ne__(self, other: object) -> bool: pass
+    def __init__(self) -> None:
+        pass
+    def __str__(self) -> str:
+        pass
+    def __eq__(self, other: object) -> bool:
+        pass
+    def __ne__(self, other: object) -> bool:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
 class int:
     # Note: this is a simplification of the actual signature
-    def __init__(self, x: object = ..., base: int = ...) -> None: pass
-    def __add__(self, i: int) -> int: pass
-    def __rmul__(self, x: int) -> int: pass
+    def __init__(self, x: object = ..., base: int = ...) -> None:
+        pass
+    def __add__(self, i: int) -> int:
+        pass
+    def __rmul__(self, x: int) -> int:
+        pass
+
 class float:
-    def __float__(self) -> float: pass
-    def __add__(self, x: float) -> float: pass
+    def __float__(self) -> float:
+        pass
+    def __add__(self, x: float) -> float:
+        pass
+
 class complex:
-    def __add__(self, x: complex) -> complex: pass
-class bool(int): pass
+    def __add__(self, x: complex) -> complex:
+        pass
+
+class bool(int):
+    pass
+
 class str(Sequence[str]):
-    def __add__(self, s: str) -> str: pass
-    def __iter__(self) -> Iterator[str]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> str: pass
-    def format(self, *args, **kwargs) -> str: pass
+    def __add__(self, s: str) -> str:
+        pass
+    def __iter__(self) -> Iterator[str]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> str:
+        pass
+    def format(self, *args, **kwargs) -> str:
+        pass
+
 class bytes(Sequence[int]):
-    def __iter__(self) -> Iterator[int]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> int: pass
+    def __iter__(self) -> Iterator[int]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> int:
+        pass
+
 class bytearray(Sequence[int]):
-    def __init__(self, x: bytes) -> None: pass
-    def __iter__(self) -> Iterator[int]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> int: pass
+    def __init__(self, x: bytes) -> None:
+        pass
+    def __iter__(self) -> Iterator[int]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> int:
+        pass
+
 class memoryview(Sequence[int]):
-    def __init__(self, x: bytes) -> None: pass
-    def __iter__(self) -> Iterator[int]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> int: pass
-class tuple(Generic[T]): pass
+    def __init__(self, x: bytes) -> None:
+        pass
+    def __iter__(self) -> Iterator[int]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> int:
+        pass
+
+class tuple(Generic[T]):
+    pass
+
 class list(Sequence[T]):
-    def __iter__(self) -> Iterator[T]: pass
-    def __contains__(self, other: object) -> bool: pass
-    def __getitem__(self, item: int) -> T: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+    def __getitem__(self, item: int) -> T:
+        pass
+
 class dict(Mapping[T, V]):
-    def __iter__(self) -> Iterator[T]: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+
 class set(Iterable[T]):
-    def __iter__(self) -> Iterator[T]: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+
 class frozenset(Iterable[T]):
-    def __iter__(self) -> Iterator[T]: pass
-class function: pass
-class ellipsis: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+
+class function:
+    pass
+
+class ellipsis:
+    pass
 
 class range(Sequence[int]):
-    def __init__(self, __x: int, __y: int = ..., __z: int = ...) -> None: pass
-    def count(self, value: int) -> int: pass
-    def index(self, value: int) -> int: pass
-    def __getitem__(self, i: int) -> int: pass
-    def __iter__(self) -> Iterator[int]: pass
-    def __contains__(self, other: object) -> bool: pass
-
-def isinstance(x: object, t: Union[type, Tuple]) -> bool: pass
+    def __init__(self, __x: int, __y: int = ..., __z: int = ...) -> None:
+        pass
+    def count(self, value: int) -> int:
+        pass
+    def index(self, value: int) -> int:
+        pass
+    def __getitem__(self, i: int) -> int:
+        pass
+    def __iter__(self) -> Iterator[int]:
+        pass
+    def __contains__(self, other: object) -> bool:
+        pass
+
+def isinstance(x: object, t: Union[type, Tuple]) -> bool:
+    pass
diff --git a/test-data/unit/fixtures/property.pyi b/test-data/unit/fixtures/property.pyi
index 667bdc02d..1a482a6da 100644
--- a/test-data/unit/fixtures/property.pyi
+++ b/test-data/unit/fixtures/property.pyi
@@ -1,25 +1,46 @@
 import typing
 
-_T = typing.TypeVar('_T')
+_T = typing.TypeVar("_T")
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x: typing.Any) -> None: pass
+    def __init__(self, x: typing.Any) -> None:
+        pass
 
-class function: pass
+class function:
+    pass
 
 property = object()  # Dummy definition
-class classmethod: pass
-
-class list: pass
-class dict: pass
-class int: pass
-class float: pass
-class str: pass
-class bytes: pass
-class bool: pass
-class ellipsis: pass
-
-class tuple(typing.Generic[_T]): pass
+
+class classmethod:
+    pass
+
+class list:
+    pass
+
+class dict:
+    pass
+
+class int:
+    pass
+
+class float:
+    pass
+
+class str:
+    pass
+
+class bytes:
+    pass
+
+class bool:
+    pass
+
+class ellipsis:
+    pass
+
+class tuple(typing.Generic[_T]):
+    pass
diff --git a/test-data/unit/fixtures/set.pyi b/test-data/unit/fixtures/set.pyi
index 71d3bd2ee..0b35358aa 100644
--- a/test-data/unit/fixtures/set.pyi
+++ b/test-data/unit/fixtures/set.pyi
@@ -2,28 +2,49 @@
 
 from typing import TypeVar, Generic, Iterator, Iterable, Set
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self) -> None: pass
-    def __eq__(self, other): pass
+    def __init__(self) -> None:
+        pass
+    def __eq__(self, other):
+        pass
 
-class type: pass
-class tuple(Generic[T]): pass
-class function: pass
+class type:
+    pass
 
-class int: pass
-class str: pass
-class bool: pass
-class ellipsis: pass
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class bool:
+    pass
+
+class ellipsis:
+    pass
 
 class set(Iterable[T], Generic[T]):
     def __init__(self, iterable: Iterable[T] = ...) -> None: ...
-    def __iter__(self) -> Iterator[T]: pass
-    def __contains__(self, item: object) -> bool: pass
-    def __ior__(self, x: Set[T]) -> None: pass
-    def add(self, x: T) -> None: pass
-    def discard(self, x: T) -> None: pass
-    def update(self, x: Set[T]) -> None: pass
-
-class dict: pass
+    def __iter__(self) -> Iterator[T]:
+        pass
+    def __contains__(self, item: object) -> bool:
+        pass
+    def __ior__(self, x: Set[T]) -> None:
+        pass
+    def add(self, x: T) -> None:
+        pass
+    def discard(self, x: T) -> None:
+        pass
+    def update(self, x: Set[T]) -> None:
+        pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/slice.pyi b/test-data/unit/fixtures/slice.pyi
index b22a12b52..7d3630c69 100644
--- a/test-data/unit/fixtures/slice.pyi
+++ b/test-data/unit/fixtures/slice.pyi
@@ -1,19 +1,36 @@
 # Builtins stub used in slicing test cases.
 from typing import Generic, TypeVar
-T = TypeVar('T')
+
+T = TypeVar("T")
 
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
+
+class type:
+    pass
+
+class tuple(Generic[T]):
+    pass
+
+class function:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class slice:
+    pass
 
-class type: pass
-class tuple(Generic[T]): pass
-class function: pass
+class ellipsis:
+    pass
 
-class int: pass
-class str: pass
+class dict:
+    pass
 
-class slice: pass
-class ellipsis: pass
-class dict: pass
 class list(Generic[T]):
-    def __getitem__(self, x: slice) -> list[T]: pass
+    def __getitem__(self, x: slice) -> list[T]:
+        pass
diff --git a/test-data/unit/fixtures/staticmethod.pyi b/test-data/unit/fixtures/staticmethod.pyi
index 8a87121b2..f12aed6e5 100644
--- a/test-data/unit/fixtures/staticmethod.pyi
+++ b/test-data/unit/fixtures/staticmethod.pyi
@@ -1,21 +1,32 @@
 import typing
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x) -> None: pass
+    def __init__(self, x) -> None:
+        pass
 
-class function: pass
+class function:
+    pass
 
-staticmethod = object() # Dummy definition.
+staticmethod = object()  # Dummy definition.
 property = object()  # Dummy definition
 
 class int:
     @staticmethod
-    def from_bytes(bytes: bytes, byteorder: str) -> int: pass
+    def from_bytes(bytes: bytes, byteorder: str) -> int:
+        pass
 
-class str: pass
-class bytes: pass
-class ellipsis: pass
-class dict: pass
+class str:
+    pass
+
+class bytes:
+    pass
+
+class ellipsis:
+    pass
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/transform.pyi b/test-data/unit/fixtures/transform.pyi
index 7dbb8fa90..6266142c6 100644
--- a/test-data/unit/fixtures/transform.pyi
+++ b/test-data/unit/fixtures/transform.pyi
@@ -1,20 +1,24 @@
 # Builtins stubs used implicitly in program transformation test cases.
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
-class type: pass
+class type:
+    pass
 
 # str is handy for debugging; allows outputting messages.
-class str: pass
+class str:
+    pass
 
 # Primitive types int/float have special coercion behaviour (they may have
 # a different representation from ordinary values).
 
-class int: pass
-
-class float: pass
+class int:
+    pass
 
+class float:
+    pass
 
 # The functions below are special functions used in test cases; their
 # implementations are actually in the __dynchk module, but they are defined
@@ -29,4 +33,5 @@ def __print(a1=None, a2=None, a3=None, a4=None):
     # cases.
     pass
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/tuple-simple.pyi b/test-data/unit/fixtures/tuple-simple.pyi
index 6c816c1c5..6f6885680 100644
--- a/test-data/unit/fixtures/tuple-simple.pyi
+++ b/test-data/unit/fixtures/tuple-simple.pyi
@@ -5,17 +5,28 @@
 
 from typing import Iterable, TypeVar, Generic
 
-T = TypeVar('T')
+T = TypeVar("T")
 
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
+
+class type:
+    pass
 
-class type: pass
 class tuple(Generic[T]):
-    def __getitem__(self, x: int) -> T: pass
-class function: pass
+    def __getitem__(self, x: int) -> T:
+        pass
+
+class function:
+    pass
 
 # We need int for indexing tuples.
-class int: pass
-class str: pass # For convenience
-class dict: pass
+class int:
+    pass
+
+class str:
+    pass  # For convenience
+
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/tuple.pyi b/test-data/unit/fixtures/tuple.pyi
index e270f3d79..f232531d0 100644
--- a/test-data/unit/fixtures/tuple.pyi
+++ b/test-data/unit/fixtures/tuple.pyi
@@ -4,40 +4,69 @@ import _typeshed
 from typing import Iterable, Iterator, TypeVar, Generic, Sequence, Optional, overload, Tuple, Type
 
 T = TypeVar("T")
-Tco = TypeVar('Tco', covariant=True)
+Tco = TypeVar("Tco", covariant=True)
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, *a: object) -> None: pass
-    def __call__(self, *a: object) -> object: pass
+    def __init__(self, *a: object) -> None:
+        pass
+    def __call__(self, *a: object) -> object:
+        pass
+
 class tuple(Sequence[Tco], Generic[Tco]):
     def __new__(cls: Type[T], iterable: Iterable[Tco] = ...) -> T: ...
-    def __iter__(self) -> Iterator[Tco]: pass
-    def __contains__(self, item: object) -> bool: pass
+    def __iter__(self) -> Iterator[Tco]:
+        pass
+    def __contains__(self, item: object) -> bool:
+        pass
     @overload
-    def __getitem__(self, x: int) -> Tco: pass
+    def __getitem__(self, x: int) -> Tco:
+        pass
     @overload
     def __getitem__(self, x: slice) -> Tuple[Tco, ...]: ...
-    def __mul__(self, n: int) -> Tuple[Tco, ...]: pass
-    def __rmul__(self, n: int) -> Tuple[Tco, ...]: pass
-    def __add__(self, x: Tuple[Tco, ...]) -> Tuple[Tco, ...]: pass
-    def count(self, obj: object) -> int: pass
+    def __mul__(self, n: int) -> Tuple[Tco, ...]:
+        pass
+    def __rmul__(self, n: int) -> Tuple[Tco, ...]:
+        pass
+    def __add__(self, x: Tuple[Tco, ...]) -> Tuple[Tco, ...]:
+        pass
+    def count(self, obj: object) -> int:
+        pass
+
 class function:
     __name__: str
-class ellipsis: pass
-class classmethod: pass
+
+class ellipsis:
+    pass
+
+class classmethod:
+    pass
 
 # We need int and slice for indexing tuples.
 class int:
-    def __neg__(self) -> 'int': pass
-class float: pass
-class slice: pass
-class bool(int): pass
-class str: pass # For convenience
-class bytes: pass
-class bytearray: pass
+    def __neg__(self) -> "int":
+        pass
+
+class float:
+    pass
+
+class slice:
+    pass
+
+class bool(int):
+    pass
+
+class str:
+    pass  # For convenience
+
+class bytes:
+    pass
+
+class bytearray:
+    pass
 
 class list(Sequence[T], Generic[T]):
     @overload
@@ -47,10 +76,14 @@ class list(Sequence[T], Generic[T]):
     def __contains__(self, item: object) -> bool: ...
     def __iter__(self) -> Iterator[T]: ...
 
-def isinstance(x: object, t: type) -> bool: pass
+def isinstance(x: object, t: type) -> bool:
+    pass
 
-def sum(iterable: Iterable[T], start: Optional[T] = None) -> T: pass
+def sum(iterable: Iterable[T], start: Optional[T] = None) -> T:
+    pass
 
-class BaseException: pass
+class BaseException:
+    pass
 
-class dict: pass
+class dict:
+    pass
diff --git a/test-data/unit/fixtures/type.pyi b/test-data/unit/fixtures/type.pyi
index 39357a693..29a36c904 100644
--- a/test-data/unit/fixtures/type.pyi
+++ b/test-data/unit/fixtures/type.pyi
@@ -6,22 +6,42 @@ T = TypeVar("T")
 S = TypeVar("S")
 
 class object:
-    def __init__(self) -> None: pass
-    def __str__(self) -> 'str': pass
+    def __init__(self) -> None:
+        pass
+    def __str__(self) -> "str":
+        pass
 
-class list(Generic[T]): pass
+class list(Generic[T]):
+    pass
 
 class type(Generic[T]):
     __name__: str
-    def __call__(self, *args: Any, **kwargs: Any) -> Any: pass
-    def __or__(self, other: Union[type, None]) -> type: pass
-    def __ror__(self, other: Union[type, None]) -> type: pass
-    def mro(self) -> List['type']: pass
-
-class tuple(Generic[T]): pass
-class dict(Generic[T, S]): pass
-class function: pass
-class bool: pass
-class int: pass
-class str: pass
-class ellipsis: pass
+    def __call__(self, *args: Any, **kwargs: Any) -> Any:
+        pass
+    def __or__(self, other: Union[type, None]) -> type:
+        pass
+    def __ror__(self, other: Union[type, None]) -> type:
+        pass
+    def mro(self) -> List["type"]:
+        pass
+
+class tuple(Generic[T]):
+    pass
+
+class dict(Generic[T, S]):
+    pass
+
+class function:
+    pass
+
+class bool:
+    pass
+
+class int:
+    pass
+
+class str:
+    pass
+
+class ellipsis:
+    pass
diff --git a/test-data/unit/fixtures/typing-async.pyi b/test-data/unit/fixtures/typing-async.pyi
index b207dd599..af3a5bffc 100644
--- a/test-data/unit/fixtures/typing-async.pyi
+++ b/test-data/unit/fixtures/typing-async.pyi
@@ -25,12 +25,12 @@ Final = 0
 Literal = 0
 NoReturn = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-T_contra = TypeVar('T_contra', contravariant=True)
-U = TypeVar('U')
-V = TypeVar('V')
-S = TypeVar('S')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+T_contra = TypeVar("T_contra", contravariant=True)
+U = TypeVar("U")
+V = TypeVar("V")
+S = TypeVar("S")
 
 # Note: definitions below are different from typeshed, variances are declared
 # to silence the protocol variance checks. Maybe it is better to use type: ignore?
@@ -38,89 +38,108 @@ S = TypeVar('S')
 class Container(Protocol[T_co]):
     @abstractmethod
     # Use int because bool isn't in the default test builtins
-    def __contains__(self, arg: object) -> int: pass
+    def __contains__(self, arg: object) -> int:
+        pass
 
 class Iterable(Protocol[T_co]):
     @abstractmethod
-    def __iter__(self) -> 'Iterator[T_co]': pass
+    def __iter__(self) -> "Iterator[T_co]":
+        pass
 
 class Iterator(Iterable[T_co], Protocol):
     @abstractmethod
-    def __next__(self) -> T_co: pass
+    def __next__(self) -> T_co:
+        pass
 
 class Generator(Iterator[T], Generic[T, U, V]):
     @abstractmethod
-    def send(self, value: U) -> T: pass
-
+    def send(self, value: U) -> T:
+        pass
     @abstractmethod
-    def throw(self, typ: Any, val: Any=None, tb: Any=None) -> None: pass
-
+    def throw(self, typ: Any, val: Any = None, tb: Any = None) -> None:
+        pass
     @abstractmethod
-    def close(self) -> None: pass
-
+    def close(self) -> None:
+        pass
     @abstractmethod
-    def __iter__(self) -> 'Generator[T, U, V]': pass
+    def __iter__(self) -> "Generator[T, U, V]":
+        pass
 
 class AsyncGenerator(AsyncIterator[T], Generic[T, U]):
     @abstractmethod
-    def __anext__(self) -> Awaitable[T]: pass
-
+    def __anext__(self) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def asend(self, value: U) -> Awaitable[T]: pass
-
+    def asend(self, value: U) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def athrow(self, typ: Any, val: Any=None, tb: Any=None) -> Awaitable[T]: pass
-
+    def athrow(self, typ: Any, val: Any = None, tb: Any = None) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def aclose(self) -> Awaitable[T]: pass
-
+    def aclose(self) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def __aiter__(self) -> 'AsyncGenerator[T, U]': pass
+    def __aiter__(self) -> "AsyncGenerator[T, U]":
+        pass
 
 class Awaitable(Protocol[T]):
     @abstractmethod
-    def __await__(self) -> Generator[Any, Any, T]: pass
+    def __await__(self) -> Generator[Any, Any, T]:
+        pass
 
 class AwaitableGenerator(Generator[T, U, V], Awaitable[V], Generic[T, U, V, S], metaclass=ABCMeta):
     pass
 
 class Coroutine(Awaitable[V], Generic[T, U, V]):
     @abstractmethod
-    def send(self, value: U) -> T: pass
-
+    def send(self, value: U) -> T:
+        pass
     @abstractmethod
-    def throw(self, typ: Any, val: Any=None, tb: Any=None) -> None: pass
-
+    def throw(self, typ: Any, val: Any = None, tb: Any = None) -> None:
+        pass
     @abstractmethod
-    def close(self) -> None: pass
+    def close(self) -> None:
+        pass
 
 class AsyncIterable(Protocol[T]):
     @abstractmethod
-    def __aiter__(self) -> 'AsyncIterator[T]': pass
+    def __aiter__(self) -> "AsyncIterator[T]":
+        pass
 
 class AsyncIterator(AsyncIterable[T], Protocol):
-    def __aiter__(self) -> 'AsyncIterator[T]': return self
+    def __aiter__(self) -> "AsyncIterator[T]":
+        return self
     @abstractmethod
-    def __anext__(self) -> Awaitable[T]: pass
+    def __anext__(self) -> Awaitable[T]:
+        pass
 
 class Sequence(Iterable[T_co], Container[T_co]):
     @abstractmethod
-    def __getitem__(self, n: Any) -> T_co: pass
+    def __getitem__(self, n: Any) -> T_co:
+        pass
 
 class Mapping(Iterable[T], Generic[T, T_co], metaclass=ABCMeta):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
     @overload
-    def get(self, k: T) -> Optional[T_co]: pass
+    def get(self, k: T) -> Optional[T_co]:
+        pass
     @overload
-    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]: pass
+    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]:
+        pass
 
 class ContextManager(Generic[T]):
-    def __enter__(self) -> T: pass
+    def __enter__(self) -> T:
+        pass
     # Use Any because not all the precise types are in the fixtures.
-    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any: pass
+    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
+        pass
 
 class AsyncContextManager(Generic[T]):
-    def __aenter__(self) -> Awaitable[T]: pass
+    def __aenter__(self) -> Awaitable[T]:
+        pass
     # Use Any because not all the precise types are in the fixtures.
-    def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Awaitable[Any]: pass
+    def __aexit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Awaitable[Any]:
+        pass
diff --git a/test-data/unit/fixtures/typing-full.pyi b/test-data/unit/fixtures/typing-full.pyi
index 417ae6baf..8269565ea 100644
--- a/test-data/unit/fixtures/typing-full.pyi
+++ b/test-data/unit/fixtures/typing-full.pyi
@@ -8,10 +8,12 @@
 
 from abc import abstractmethod, ABCMeta
 
-class GenericMeta(type): pass
+class GenericMeta(type):
+    pass
 
 def cast(t, o): ...
 def assert_type(o, t): ...
+
 overload = 0
 Any = 0
 Union = 0
@@ -31,12 +33,12 @@ TypedDict = 0
 NoReturn = 0
 NewType = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-T_contra = TypeVar('T_contra', contravariant=True)
-U = TypeVar('U')
-V = TypeVar('V')
-S = TypeVar('S')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+T_contra = TypeVar("T_contra", contravariant=True)
+U = TypeVar("U")
+V = TypeVar("V")
+S = TypeVar("S")
 
 class NamedTuple(tuple[Any, ...]): ...
 
@@ -46,125 +48,151 @@ class NamedTuple(tuple[Any, ...]): ...
 @runtime_checkable
 class Hashable(Protocol, metaclass=ABCMeta):
     @abstractmethod
-    def __hash__(self) -> int: pass
+    def __hash__(self) -> int:
+        pass
 
 @runtime_checkable
 class Container(Protocol[T_co]):
     @abstractmethod
     # Use int because bool isn't in the default test builtins
-    def __contains__(self, arg: object) -> int: pass
+    def __contains__(self, arg: object) -> int:
+        pass
 
 @runtime_checkable
 class Sized(Protocol):
     @abstractmethod
-    def __len__(self) -> int: pass
+    def __len__(self) -> int:
+        pass
 
 @runtime_checkable
 class Iterable(Protocol[T_co]):
     @abstractmethod
-    def __iter__(self) -> 'Iterator[T_co]': pass
+    def __iter__(self) -> "Iterator[T_co]":
+        pass
 
 @runtime_checkable
 class Iterator(Iterable[T_co], Protocol):
     @abstractmethod
-    def __next__(self) -> T_co: pass
+    def __next__(self) -> T_co:
+        pass
 
 class Generator(Iterator[T], Generic[T, U, V]):
     @abstractmethod
-    def send(self, value: U) -> T: pass
-
+    def send(self, value: U) -> T:
+        pass
     @abstractmethod
-    def throw(self, typ: Any, val: Any=None, tb: Any=None) -> None: pass
-
+    def throw(self, typ: Any, val: Any = None, tb: Any = None) -> None:
+        pass
     @abstractmethod
-    def close(self) -> None: pass
-
+    def close(self) -> None:
+        pass
     @abstractmethod
-    def __iter__(self) -> 'Generator[T, U, V]': pass
+    def __iter__(self) -> "Generator[T, U, V]":
+        pass
 
 class AsyncGenerator(AsyncIterator[T], Generic[T, U]):
     @abstractmethod
-    def __anext__(self) -> Awaitable[T]: pass
-
+    def __anext__(self) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def asend(self, value: U) -> Awaitable[T]: pass
-
+    def asend(self, value: U) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def athrow(self, typ: Any, val: Any=None, tb: Any=None) -> Awaitable[T]: pass
-
+    def athrow(self, typ: Any, val: Any = None, tb: Any = None) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def aclose(self) -> Awaitable[T]: pass
-
+    def aclose(self) -> Awaitable[T]:
+        pass
     @abstractmethod
-    def __aiter__(self) -> 'AsyncGenerator[T, U]': pass
+    def __aiter__(self) -> "AsyncGenerator[T, U]":
+        pass
 
 @runtime_checkable
 class Awaitable(Protocol[T]):
     @abstractmethod
-    def __await__(self) -> Generator[Any, Any, T]: pass
+    def __await__(self) -> Generator[Any, Any, T]:
+        pass
 
 class AwaitableGenerator(Generator[T, U, V], Awaitable[V], Generic[T, U, V, S], metaclass=ABCMeta):
     pass
 
 class Coroutine(Awaitable[V], Generic[T, U, V]):
     @abstractmethod
-    def send(self, value: U) -> T: pass
-
+    def send(self, value: U) -> T:
+        pass
     @abstractmethod
-    def throw(self, typ: Any, val: Any=None, tb: Any=None) -> None: pass
-
+    def throw(self, typ: Any, val: Any = None, tb: Any = None) -> None:
+        pass
     @abstractmethod
-    def close(self) -> None: pass
+    def close(self) -> None:
+        pass
 
 @runtime_checkable
 class AsyncIterable(Protocol[T]):
     @abstractmethod
-    def __aiter__(self) -> 'AsyncIterator[T]': pass
+    def __aiter__(self) -> "AsyncIterator[T]":
+        pass
 
 @runtime_checkable
 class AsyncIterator(AsyncIterable[T], Protocol):
-    def __aiter__(self) -> 'AsyncIterator[T]': return self
+    def __aiter__(self) -> "AsyncIterator[T]":
+        return self
     @abstractmethod
-    def __anext__(self) -> Awaitable[T]: pass
+    def __anext__(self) -> Awaitable[T]:
+        pass
 
 class Sequence(Iterable[T_co], Container[T_co]):
     @abstractmethod
-    def __getitem__(self, n: Any) -> T_co: pass
+    def __getitem__(self, n: Any) -> T_co:
+        pass
 
 class MutableSequence(Sequence[T]):
     @abstractmethod
-    def __setitem__(self, n: Any, o: T) -> None: pass
+    def __setitem__(self, n: Any, o: T) -> None:
+        pass
 
 class Mapping(Iterable[T], Generic[T, T_co], metaclass=ABCMeta):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
     @overload
-    def get(self, k: T) -> Optional[T_co]: pass
+    def get(self, k: T) -> Optional[T_co]:
+        pass
     @overload
-    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]: pass
-    def values(self) -> Iterable[T_co]: pass  # Approximate return type
+    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]:
+        pass
+    def values(self) -> Iterable[T_co]:
+        pass  # Approximate return type
     def __len__(self) -> int: ...
-    def __contains__(self, arg: object) -> int: pass
+    def __contains__(self, arg: object) -> int:
+        pass
 
 class MutableMapping(Mapping[T, U], metaclass=ABCMeta):
-    def __setitem__(self, k: T, v: U) -> None: pass
+    def __setitem__(self, k: T, v: U) -> None:
+        pass
 
 class SupportsInt(Protocol):
-    def __int__(self) -> int: pass
+    def __int__(self) -> int:
+        pass
 
 class SupportsFloat(Protocol):
-    def __float__(self) -> float: pass
+    def __float__(self) -> float:
+        pass
 
 class SupportsAbs(Protocol[T_co]):
-    def __abs__(self) -> T_co: pass
+    def __abs__(self) -> T_co:
+        pass
 
 def runtime_checkable(cls: T) -> T:
     return cls
 
 class ContextManager(Generic[T_co]):
-    def __enter__(self) -> T_co: pass
+    def __enter__(self) -> T_co:
+        pass
     # Use Any because not all the precise types are in the fixtures.
-    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any: pass
+    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
+        pass
 
 TYPE_CHECKING = 1
 
@@ -181,7 +209,8 @@ class _TypedDict(Mapping[str, object]):
     def update(self: T, __m: T) -> None: ...
     def __delitem__(self, k: NoReturn) -> None: ...
 
-class _SpecialForm: pass
+class _SpecialForm:
+    pass
 
 def dataclass_transform(
     *,
diff --git a/test-data/unit/fixtures/typing-medium.pyi b/test-data/unit/fixtures/typing-medium.pyi
index 03be1d0a6..ce743e185 100644
--- a/test-data/unit/fixtures/typing-medium.pyi
+++ b/test-data/unit/fixtures/typing-medium.pyi
@@ -29,46 +29,58 @@ NewType = 0
 TypeAlias = 0
 LiteralString = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-T_contra = TypeVar('T_contra', contravariant=True)
-U = TypeVar('U')
-V = TypeVar('V')
-S = TypeVar('S')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+T_contra = TypeVar("T_contra", contravariant=True)
+U = TypeVar("U")
+V = TypeVar("V")
+S = TypeVar("S")
 
 # Note: definitions below are different from typeshed, variances are declared
 # to silence the protocol variance checks. Maybe it is better to use type: ignore?
 
 class Sized(Protocol):
-    def __len__(self) -> int: pass
+    def __len__(self) -> int:
+        pass
 
 class Iterable(Protocol[T_co]):
-    def __iter__(self) -> 'Iterator[T_co]': pass
+    def __iter__(self) -> "Iterator[T_co]":
+        pass
 
 class Iterator(Iterable[T_co], Protocol):
-    def __next__(self) -> T_co: pass
+    def __next__(self) -> T_co:
+        pass
 
 class Generator(Iterator[T], Generic[T, U, V]):
-    def __iter__(self) -> 'Generator[T, U, V]': pass
+    def __iter__(self) -> "Generator[T, U, V]":
+        pass
 
 class Sequence(Iterable[T_co]):
-    def __getitem__(self, n: Any) -> T_co: pass
+    def __getitem__(self, n: Any) -> T_co:
+        pass
 
 class Mapping(Iterable[T], Generic[T, T_co]):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
 
 class SupportsInt(Protocol):
-    def __int__(self) -> int: pass
+    def __int__(self) -> int:
+        pass
 
 class SupportsFloat(Protocol):
-    def __float__(self) -> float: pass
+    def __float__(self) -> float:
+        pass
 
 class ContextManager(Generic[T]):
-    def __enter__(self) -> T: pass
+    def __enter__(self) -> T:
+        pass
     # Use Any because not all the precise types are in the fixtures.
-    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any: pass
+    def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> Any:
+        pass
 
-class _SpecialForm: pass
+class _SpecialForm:
+    pass
 
 TYPE_CHECKING = 1
diff --git a/test-data/unit/fixtures/typing-namedtuple.pyi b/test-data/unit/fixtures/typing-namedtuple.pyi
index c8658a815..41324ff86 100644
--- a/test-data/unit/fixtures/typing-namedtuple.pyi
+++ b/test-data/unit/fixtures/typing-namedtuple.pyi
@@ -7,17 +7,27 @@ Literal = 0
 Optional = 0
 Self = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-KT = TypeVar('KT')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+KT = TypeVar("KT")
+
+class Iterable(Generic[T_co]):
+    pass
+
+class Iterator(Iterable[T_co]):
+    pass
+
+class Sequence(Iterable[T_co]):
+    pass
 
-class Iterable(Generic[T_co]): pass
-class Iterator(Iterable[T_co]): pass
-class Sequence(Iterable[T_co]): pass
 class Mapping(Iterable[KT], Generic[KT, T_co]):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
+
+class Tuple(Sequence):
+    pass
 
-class Tuple(Sequence): pass
 class NamedTuple(Tuple):
     name: str
diff --git a/test-data/unit/fixtures/typing-typeddict.pyi b/test-data/unit/fixtures/typing-typeddict.pyi
index 24a2f1328..c15fb0531 100644
--- a/test-data/unit/fixtures/typing-typeddict.pyi
+++ b/test-data/unit/fixtures/typing-typeddict.pyi
@@ -28,36 +28,46 @@ Required = 0
 NotRequired = 0
 Self = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-V = TypeVar('V')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+V = TypeVar("V")
 
 # Note: definitions below are different from typeshed, variances are declared
 # to silence the protocol variance checks. Maybe it is better to use type: ignore?
 
 class Sized(Protocol):
-    def __len__(self) -> int: pass
+    def __len__(self) -> int:
+        pass
 
 class Iterable(Protocol[T_co]):
-    def __iter__(self) -> 'Iterator[T_co]': pass
+    def __iter__(self) -> "Iterator[T_co]":
+        pass
 
 class Iterator(Iterable[T_co], Protocol):
-    def __next__(self) -> T_co: pass
+    def __next__(self) -> T_co:
+        pass
 
 class Sequence(Iterable[T_co]):
     # misc is for explicit Any.
-    def __getitem__(self, n: Any) -> T_co: pass # type: ignore[misc]
+    def __getitem__(self, n: Any) -> T_co:
+        pass  # type: ignore[misc]
 
 class Mapping(Iterable[T], Generic[T, T_co], metaclass=ABCMeta):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
     @overload
-    def get(self, k: T) -> Optional[T_co]: pass
+    def get(self, k: T) -> Optional[T_co]:
+        pass
     @overload
-    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]: pass
-    def values(self) -> Iterable[T_co]: pass  # Approximate return type
+    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]:
+        pass
+    def values(self) -> Iterable[T_co]:
+        pass  # Approximate return type
     def __len__(self) -> int: ...
-    def __contains__(self, arg: object) -> int: pass
+    def __contains__(self, arg: object) -> int:
+        pass
 
 # Fallback type for all typed dicts (does not exist at runtime).
 class _TypedDict(Mapping[str, object]):
diff --git a/test-data/unit/fixtures/union.pyi b/test-data/unit/fixtures/union.pyi
index 350e145a6..15d62c5b7 100644
--- a/test-data/unit/fixtures/union.pyi
+++ b/test-data/unit/fixtures/union.pyi
@@ -2,17 +2,28 @@
 
 from isinstance import isinstance
 from typing import Iterable, TypeVar, Generic
-T = TypeVar('T')
+
+T = TypeVar("T")
 
 class object:
-    def __init__(self): pass
+    def __init__(self):
+        pass
+
+class type:
+    pass
 
-class type: pass
-class function: pass
+class function:
+    pass
 
-class tuple(Generic[T]): pass
+class tuple(Generic[T]):
+    pass
 
 # We need int for indexing tuples.
-class int: pass
-class str: pass # For convenience
-class dict: pass
+class int:
+    pass
+
+class str:
+    pass  # For convenience
+
+class dict:
+    pass
diff --git a/test-data/unit/lib-stub/_typeshed.pyi b/test-data/unit/lib-stub/_typeshed.pyi
index 054ad0ec0..5044082ba 100644
--- a/test-data/unit/lib-stub/_typeshed.pyi
+++ b/test-data/unit/lib-stub/_typeshed.pyi
@@ -4,5 +4,7 @@ _KT = TypeVar("_KT")
 _VT_co = TypeVar("_VT_co", covariant=True)
 
 class SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):
-    def keys(self) -> Iterable[_KT]: pass
-    def __getitem__(self, __key: _KT) -> _VT_co: pass
+    def keys(self) -> Iterable[_KT]:
+        pass
+    def __getitem__(self, __key: _KT) -> _VT_co:
+        pass
diff --git a/test-data/unit/lib-stub/abc.pyi b/test-data/unit/lib-stub/abc.pyi
index e60f709a5..0b8dd0984 100644
--- a/test-data/unit/lib-stub/abc.pyi
+++ b/test-data/unit/lib-stub/abc.pyi
@@ -1,9 +1,13 @@
 from typing import Type, Any, TypeVar
 
-T = TypeVar('T', bound=Type[Any])
+T = TypeVar("T", bound=Type[Any])
 
 class ABCMeta(type):
-    def register(cls, tp: T) -> T: pass
-class ABC(metaclass=ABCMeta): pass
+    def register(cls, tp: T) -> T:
+        pass
+
+class ABC(metaclass=ABCMeta):
+    pass
+
 abstractmethod = object()
 abstractproperty = object()
diff --git a/test-data/unit/lib-stub/attr/__init__.pyi b/test-data/unit/lib-stub/attr/__init__.pyi
index 1a3838aa3..067f7388d 100644
--- a/test-data/unit/lib-stub/attr/__init__.pyi
+++ b/test-data/unit/lib-stub/attr/__init__.pyi
@@ -1,7 +1,18 @@
-from typing import TypeVar, overload, Callable, Any, Type, Optional, Union, Sequence, Mapping, Generic
+from typing import (
+    TypeVar,
+    overload,
+    Callable,
+    Any,
+    Type,
+    Optional,
+    Union,
+    Sequence,
+    Mapping,
+    Generic,
+)
 
-_T = TypeVar('_T')
-_C = TypeVar('_C', bound=type)
+_T = TypeVar("_T")
+_C = TypeVar("_C", bound=type)
 
 _ValidatorType = Callable[[Any, Any, _T], Any]
 _ConverterType = Callable[[Any], _T]
@@ -10,119 +21,127 @@ _ValidatorArgType = Union[_ValidatorType[_T], Sequence[_ValidatorType[_T]]]
 
 # This form catches explicit None or no default but with no other arguments returns Any.
 @overload
-def attrib(default: None = ...,
-           validator: None = ...,
-           repr: bool = ...,
-           cmp: Optional[bool] = ...,
-           hash: Optional[bool] = ...,
-           init: bool = ...,
-           convert: None = ...,
-           metadata: Optional[Mapping[Any, Any]] = ...,
-           type: None = ...,
-           converter: None = ...,
-           factory: None = ...,
-           kw_only: bool = ...,
-           eq: Optional[bool] = ...,
-           order: Optional[bool] = ...,
-           ) -> Any: ...
+def attrib(
+    default: None = ...,
+    validator: None = ...,
+    repr: bool = ...,
+    cmp: Optional[bool] = ...,
+    hash: Optional[bool] = ...,
+    init: bool = ...,
+    convert: None = ...,
+    metadata: Optional[Mapping[Any, Any]] = ...,
+    type: None = ...,
+    converter: None = ...,
+    factory: None = ...,
+    kw_only: bool = ...,
+    eq: Optional[bool] = ...,
+    order: Optional[bool] = ...,
+) -> Any: ...
+
 # This form catches an explicit None or no default and infers the type from the other arguments.
 @overload
-def attrib(default: None = ...,
-           validator: Optional[_ValidatorArgType[_T]] = ...,
-           repr: bool = ...,
-           cmp: Optional[bool] = ...,
-           hash: Optional[bool] = ...,
-           init: bool = ...,
-           convert: Optional[_ConverterType[_T]] = ...,
-           metadata: Optional[Mapping[Any, Any]] = ...,
-           type: Optional[Type[_T]] = ...,
-           converter: Optional[_ConverterType[_T]] = ...,
-           factory: Optional[Callable[[], _T]] = ...,
-           kw_only: bool = ...,
-           eq: Optional[bool] = ...,
-           order: Optional[bool] = ...,
-           ) -> _T: ...
+def attrib(
+    default: None = ...,
+    validator: Optional[_ValidatorArgType[_T]] = ...,
+    repr: bool = ...,
+    cmp: Optional[bool] = ...,
+    hash: Optional[bool] = ...,
+    init: bool = ...,
+    convert: Optional[_ConverterType[_T]] = ...,
+    metadata: Optional[Mapping[Any, Any]] = ...,
+    type: Optional[Type[_T]] = ...,
+    converter: Optional[_ConverterType[_T]] = ...,
+    factory: Optional[Callable[[], _T]] = ...,
+    kw_only: bool = ...,
+    eq: Optional[bool] = ...,
+    order: Optional[bool] = ...,
+) -> _T: ...
+
 # This form catches an explicit default argument.
 @overload
-def attrib(default: _T,
-           validator: Optional[_ValidatorArgType[_T]] = ...,
-           repr: bool = ...,
-           cmp: Optional[bool] = ...,
-           hash: Optional[bool] = ...,
-           init: bool = ...,
-           convert: Optional[_ConverterType[_T]] = ...,
-           metadata: Optional[Mapping[Any, Any]] = ...,
-           type: Optional[Type[_T]] = ...,
-           converter: Optional[_ConverterType[_T]] = ...,
-           factory: Optional[Callable[[], _T]] = ...,
-           kw_only: bool = ...,
-           eq: Optional[bool] = ...,
-           order: Optional[bool] = ...,
-           ) -> _T: ...
+def attrib(
+    default: _T,
+    validator: Optional[_ValidatorArgType[_T]] = ...,
+    repr: bool = ...,
+    cmp: Optional[bool] = ...,
+    hash: Optional[bool] = ...,
+    init: bool = ...,
+    convert: Optional[_ConverterType[_T]] = ...,
+    metadata: Optional[Mapping[Any, Any]] = ...,
+    type: Optional[Type[_T]] = ...,
+    converter: Optional[_ConverterType[_T]] = ...,
+    factory: Optional[Callable[[], _T]] = ...,
+    kw_only: bool = ...,
+    eq: Optional[bool] = ...,
+    order: Optional[bool] = ...,
+) -> _T: ...
+
 # This form covers type=non-Type: e.g. forward references (str), Any
 @overload
-def attrib(default: Optional[_T] = ...,
-           validator: Optional[_ValidatorArgType[_T]] = ...,
-           repr: bool = ...,
-           cmp: Optional[bool] = ...,
-           hash: Optional[bool] = ...,
-           init: bool = ...,
-           convert: Optional[_ConverterType[_T]] = ...,
-           metadata: Optional[Mapping[Any, Any]] = ...,
-           type: object = ...,
-           converter: Optional[_ConverterType[_T]] = ...,
-           factory: Optional[Callable[[], _T]] = ...,
-           kw_only: bool = ...,
-           eq: Optional[bool] = ...,
-           order: Optional[bool] = ...,
-           ) -> Any: ...
-
+def attrib(
+    default: Optional[_T] = ...,
+    validator: Optional[_ValidatorArgType[_T]] = ...,
+    repr: bool = ...,
+    cmp: Optional[bool] = ...,
+    hash: Optional[bool] = ...,
+    init: bool = ...,
+    convert: Optional[_ConverterType[_T]] = ...,
+    metadata: Optional[Mapping[Any, Any]] = ...,
+    type: object = ...,
+    converter: Optional[_ConverterType[_T]] = ...,
+    factory: Optional[Callable[[], _T]] = ...,
+    kw_only: bool = ...,
+    eq: Optional[bool] = ...,
+    order: Optional[bool] = ...,
+) -> Any: ...
 @overload
-def attrs(maybe_cls: _C,
-          these: Optional[Mapping[str, Any]] = ...,
-          repr_ns: Optional[str] = ...,
-          repr: bool = ...,
-          cmp: Optional[bool] = ...,
-          hash: Optional[bool] = ...,
-          init: bool = ...,
-          slots: bool = ...,
-          frozen: bool = ...,
-          weakref_slot: bool = ...,
-          str: bool = ...,
-          auto_attribs: bool = ...,
-          kw_only: bool = ...,
-          cache_hash: bool = ...,
-          eq: Optional[bool] = ...,
-          order: Optional[bool] = ...,
-          match_args: bool = ...,
-          ) -> _C: ...
+def attrs(
+    maybe_cls: _C,
+    these: Optional[Mapping[str, Any]] = ...,
+    repr_ns: Optional[str] = ...,
+    repr: bool = ...,
+    cmp: Optional[bool] = ...,
+    hash: Optional[bool] = ...,
+    init: bool = ...,
+    slots: bool = ...,
+    frozen: bool = ...,
+    weakref_slot: bool = ...,
+    str: bool = ...,
+    auto_attribs: bool = ...,
+    kw_only: bool = ...,
+    cache_hash: bool = ...,
+    eq: Optional[bool] = ...,
+    order: Optional[bool] = ...,
+    match_args: bool = ...,
+) -> _C: ...
 @overload
-def attrs(maybe_cls: None = ...,
-          these: Optional[Mapping[str, Any]] = ...,
-          repr_ns: Optional[str] = ...,
-          repr: bool = ...,
-          cmp: Optional[bool] = ...,
-          hash: Optional[bool] = ...,
-          init: bool = ...,
-          slots: bool = ...,
-          frozen: bool = ...,
-          weakref_slot: bool = ...,
-          str: bool = ...,
-          auto_attribs: bool = ...,
-          kw_only: bool = ...,
-          cache_hash: bool = ...,
-          eq: Optional[bool] = ...,
-          order: Optional[bool] = ...,
-          match_args: bool = ...,
-          ) -> Callable[[_C], _C]: ...
-
+def attrs(
+    maybe_cls: None = ...,
+    these: Optional[Mapping[str, Any]] = ...,
+    repr_ns: Optional[str] = ...,
+    repr: bool = ...,
+    cmp: Optional[bool] = ...,
+    hash: Optional[bool] = ...,
+    init: bool = ...,
+    slots: bool = ...,
+    frozen: bool = ...,
+    weakref_slot: bool = ...,
+    str: bool = ...,
+    auto_attribs: bool = ...,
+    kw_only: bool = ...,
+    cache_hash: bool = ...,
+    eq: Optional[bool] = ...,
+    order: Optional[bool] = ...,
+    match_args: bool = ...,
+) -> Callable[[_C], _C]: ...
 
-class Attribute(Generic[_T]): pass
+class Attribute(Generic[_T]):
+    pass
 
 # aliases
 s = attributes = attrs
 ib = attr = attrib
-dataclass = attrs # Technically, partial(attrs, auto_attribs=True) ;)
+dataclass = attrs  # Technically, partial(attrs, auto_attribs=True) ;)
 
 # Next Generation API
 @overload
@@ -244,6 +263,5 @@ def field(
     order: Optional[bool] = ...,
     on_setattr: Optional[object] = ...,
 ) -> Any: ...
-
 def evolve(inst: _T, **changes: Any) -> _T: ...
 def assoc(inst: _T, **changes: Any) -> _T: ...
diff --git a/test-data/unit/lib-stub/attr/converters.pyi b/test-data/unit/lib-stub/attr/converters.pyi
index 63b2a3866..cbbc629dd 100644
--- a/test-data/unit/lib-stub/attr/converters.pyi
+++ b/test-data/unit/lib-stub/attr/converters.pyi
@@ -3,9 +3,7 @@ from . import _ConverterType
 
 _T = TypeVar("_T")
 
-def optional(
-    converter: _ConverterType[_T]
-) -> _ConverterType[Optional[_T]]: ...
+def optional(converter: _ConverterType[_T]) -> _ConverterType[Optional[_T]]: ...
 @overload
 def default_if_none(default: _T) -> _ConverterType[_T]: ...
 @overload
diff --git a/test-data/unit/lib-stub/attrs/__init__.pyi b/test-data/unit/lib-stub/attrs/__init__.pyi
index 8e9aa1fdc..130be6160 100644
--- a/test-data/unit/lib-stub/attrs/__init__.pyi
+++ b/test-data/unit/lib-stub/attrs/__init__.pyi
@@ -1,7 +1,7 @@
 from typing import TypeVar, overload, Callable, Any, Optional, Union, Sequence, Mapping
 
-_T = TypeVar('_T')
-_C = TypeVar('_C', bound=type)
+_T = TypeVar("_T")
+_C = TypeVar("_C", bound=type)
 
 _ValidatorType = Callable[[Any, Any, _T], Any]
 _ConverterType = Callable[[Any], _T]
@@ -126,6 +126,5 @@ def field(
     order: Optional[bool] = ...,
     on_setattr: Optional[object] = ...,
 ) -> Any: ...
-
 def evolve(inst: _T, **changes: Any) -> _T: ...
 def assoc(inst: _T, **changes: Any) -> _T: ...
diff --git a/test-data/unit/lib-stub/attrs/converters.pyi b/test-data/unit/lib-stub/attrs/converters.pyi
index 338004908..b4dc6a327 100644
--- a/test-data/unit/lib-stub/attrs/converters.pyi
+++ b/test-data/unit/lib-stub/attrs/converters.pyi
@@ -3,9 +3,7 @@ from attr import _ConverterType
 
 _T = TypeVar("_T")
 
-def optional(
-    converter: _ConverterType[_T]
-) -> _ConverterType[Optional[_T]]: ...
+def optional(converter: _ConverterType[_T]) -> _ConverterType[Optional[_T]]: ...
 @overload
 def default_if_none(default: _T) -> _ConverterType[_T]: ...
 @overload
diff --git a/test-data/unit/lib-stub/builtins.pyi b/test-data/unit/lib-stub/builtins.pyi
index 17d519cc8..d3ed5b443 100644
--- a/test-data/unit/lib-stub/builtins.pyi
+++ b/test-data/unit/lib-stub/builtins.pyi
@@ -5,31 +5,49 @@
 import _typeshed
 
 class object:
-    def __init__(self) -> None: pass
+    def __init__(self) -> None:
+        pass
 
 class type:
-    def __init__(self, x: object) -> None: pass
+    def __init__(self, x: object) -> None:
+        pass
 
 # These are provided here for convenience.
 class int:
-    def __add__(self, other: int) -> int: pass
-class bool(int): pass
-class float: pass
+    def __add__(self, other: int) -> int:
+        pass
 
-class str: pass
-class bytes: pass
+class bool(int):
+    pass
+
+class float:
+    pass
+
+class str:
+    pass
+
+class bytes:
+    pass
 
 class function:
     __name__: str
-class ellipsis: pass
+
+class ellipsis:
+    pass
 
 from typing import Generic, Iterator, Sequence, TypeVar
-_T = TypeVar('_T')
-class list(Generic[_T], Sequence[_T]):
-    def __contains__(self, item: object) -> bool: pass
-    def __getitem__(self, key: int) -> _T: pass
-    def __iter__(self) -> Iterator[_T]: pass
 
-class dict: pass
+_T = TypeVar("_T")
+
+class list(Generic[_T], Sequence[_T]):
+    def __contains__(self, item: object) -> bool:
+        pass
+    def __getitem__(self, key: int) -> _T:
+        pass
+    def __iter__(self) -> Iterator[_T]:
+        pass
+
+class dict:
+    pass
 
 # Definition of None is implicit
diff --git a/test-data/unit/lib-stub/collections.pyi b/test-data/unit/lib-stub/collections.pyi
index 7ea264f76..edd7ce674 100644
--- a/test-data/unit/lib-stub/collections.pyi
+++ b/test-data/unit/lib-stub/collections.pyi
@@ -1,4 +1,15 @@
-from typing import Any, Iterable, Union, Dict, TypeVar, Optional, Callable, Generic, Sequence, MutableMapping
+from typing import (
+    Any,
+    Iterable,
+    Union,
+    Dict,
+    TypeVar,
+    Optional,
+    Callable,
+    Generic,
+    Sequence,
+    MutableMapping,
+)
 
 def namedtuple(
     typename: str,
@@ -7,11 +18,11 @@ def namedtuple(
     # really bool but many tests don't have bool available
     rename: int = ...,
     module: Optional[str] = ...,
-    defaults: Optional[Iterable[Any]] = ...
+    defaults: Optional[Iterable[Any]] = ...,
 ) -> Any: ...
 
-KT = TypeVar('KT')
-VT = TypeVar('VT')
+KT = TypeVar("KT")
+VT = TypeVar("VT")
 
 class OrderedDict(Dict[KT, VT]): ...
 
@@ -19,7 +30,5 @@ class defaultdict(Dict[KT, VT]):
     def __init__(self, default_factory: Optional[Callable[[], VT]]) -> None: ...
 
 class Counter(Dict[KT, int], Generic[KT]): ...
-
 class deque(Sequence[KT], Generic[KT]): ...
-
 class ChainMap(MutableMapping[KT, VT], Generic[KT, VT]): ...
diff --git a/test-data/unit/lib-stub/contextlib.pyi b/test-data/unit/lib-stub/contextlib.pyi
index ca9e91cf4..a2d6be266 100644
--- a/test-data/unit/lib-stub/contextlib.pyi
+++ b/test-data/unit/lib-stub/contextlib.pyi
@@ -1,13 +1,15 @@
 from typing import AsyncIterator, Generic, TypeVar, Callable, Iterator
 from typing import ContextManager as ContextManager, AsyncContextManager as AsyncContextManager
 
-_T = TypeVar('_T')
+_T = TypeVar("_T")
 
 class GeneratorContextManager(ContextManager[_T], Generic[_T]):
     def __call__(self, func: Callable[..., _T]) -> Callable[..., _T]: ...
 
 # This does not match `typeshed` definition, needs `ParamSpec`:
-def contextmanager(func: Callable[..., Iterator[_T]]) -> Callable[..., GeneratorContextManager[_T]]:
-    ...
-
-def asynccontextmanager(func: Callable[..., AsyncIterator[_T]]) -> Callable[..., AsyncContextManager[_T]]: ...
+def contextmanager(
+    func: Callable[..., Iterator[_T]]
+) -> Callable[..., GeneratorContextManager[_T]]: ...
+def asynccontextmanager(
+    func: Callable[..., AsyncIterator[_T]]
+) -> Callable[..., AsyncContextManager[_T]]: ...
diff --git a/test-data/unit/lib-stub/dataclasses.pyi b/test-data/unit/lib-stub/dataclasses.pyi
index bd33b4592..eaf191196 100644
--- a/test-data/unit/lib-stub/dataclasses.pyi
+++ b/test-data/unit/lib-stub/dataclasses.pyi
@@ -1,34 +1,57 @@
 from typing import Any, Callable, Generic, Mapping, Optional, TypeVar, overload, Type
 
-_T = TypeVar('_T')
-
-class InitVar(Generic[_T]):
-    ...
+_T = TypeVar("_T")
 
+class InitVar(Generic[_T]): ...
 class KW_ONLY: ...
 
 @overload
 def dataclass(_cls: Type[_T]) -> Type[_T]: ...
-
 @overload
-def dataclass(*, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ...,
-    unsafe_hash: bool = ..., frozen: bool = ..., match_args: bool = ...,
-    kw_only: bool = ..., slots: bool = ...) -> Callable[[Type[_T]], Type[_T]]: ...
-
+def dataclass(
+    *,
+    init: bool = ...,
+    repr: bool = ...,
+    eq: bool = ...,
+    order: bool = ...,
+    unsafe_hash: bool = ...,
+    frozen: bool = ...,
+    match_args: bool = ...,
+    kw_only: bool = ...,
+    slots: bool = ...,
+) -> Callable[[Type[_T]], Type[_T]]: ...
 @overload
-def field(*, default: _T,
-    init: bool = ..., repr: bool = ..., hash: Optional[bool] = ..., compare: bool = ...,
-    metadata: Optional[Mapping[str, Any]] = ..., kw_only: bool = ...,) -> _T: ...
-
+def field(
+    *,
+    default: _T,
+    init: bool = ...,
+    repr: bool = ...,
+    hash: Optional[bool] = ...,
+    compare: bool = ...,
+    metadata: Optional[Mapping[str, Any]] = ...,
+    kw_only: bool = ...,
+) -> _T: ...
 @overload
-def field(*, default_factory: Callable[[], _T],
-    init: bool = ..., repr: bool = ..., hash: Optional[bool] = ..., compare: bool = ...,
-    metadata: Optional[Mapping[str, Any]] = ..., kw_only: bool = ...,) -> _T: ...
-
+def field(
+    *,
+    default_factory: Callable[[], _T],
+    init: bool = ...,
+    repr: bool = ...,
+    hash: Optional[bool] = ...,
+    compare: bool = ...,
+    metadata: Optional[Mapping[str, Any]] = ...,
+    kw_only: bool = ...,
+) -> _T: ...
 @overload
-def field(*,
-    init: bool = ..., repr: bool = ..., hash: Optional[bool] = ..., compare: bool = ...,
-    metadata: Optional[Mapping[str, Any]] = ..., kw_only: bool = ...,) -> Any: ...
-
-
-class Field(Generic[_T]): pass
+def field(
+    *,
+    init: bool = ...,
+    repr: bool = ...,
+    hash: Optional[bool] = ...,
+    compare: bool = ...,
+    metadata: Optional[Mapping[str, Any]] = ...,
+    kw_only: bool = ...,
+) -> Any: ...
+
+class Field(Generic[_T]):
+    pass
diff --git a/test-data/unit/lib-stub/enum.pyi b/test-data/unit/lib-stub/enum.pyi
index 11adfc597..ed1183747 100644
--- a/test-data/unit/lib-stub/enum.pyi
+++ b/test-data/unit/lib-stub/enum.pyi
@@ -1,21 +1,30 @@
 from typing import Any, TypeVar, Union, Type, Sized, Iterator
 
-_T = TypeVar('_T')
+_T = TypeVar("_T")
 
 class EnumMeta(type, Sized):
-    def __len__(self) -> int: pass  # to make it non-abstract
-    def __iter__(self: Type[_T]) -> Iterator[_T]: pass
-    def __reversed__(self: Type[_T]) -> Iterator[_T]: pass
-    def __getitem__(self: Type[_T], name: str) -> _T: pass
+    def __len__(self) -> int:
+        pass  # to make it non-abstract
+    def __iter__(self: Type[_T]) -> Iterator[_T]:
+        pass
+    def __reversed__(self: Type[_T]) -> Iterator[_T]:
+        pass
+    def __getitem__(self: Type[_T], name: str) -> _T:
+        pass
 
 class Enum(metaclass=EnumMeta):
-    def __new__(cls: Type[_T], value: object) -> _T: pass
-    def __repr__(self) -> str: pass
-    def __str__(self) -> str: pass
-    def __format__(self, format_spec: str) -> str: pass
-    def __hash__(self) -> Any: pass
-    def __reduce_ex__(self, proto: Any) -> Any: pass
-
+    def __new__(cls: Type[_T], value: object) -> _T:
+        pass
+    def __repr__(self) -> str:
+        pass
+    def __str__(self) -> str:
+        pass
+    def __format__(self, format_spec: str) -> str:
+        pass
+    def __hash__(self) -> Any:
+        pass
+    def __reduce_ex__(self, proto: Any) -> Any:
+        pass
     name: str
     value: Any
     _name_: str
@@ -23,28 +32,29 @@ class Enum(metaclass=EnumMeta):
 
     # In reality, _generate_next_value_ is python3.6 only and has a different signature.
     # However, this should be quick and doesn't require additional stubs (e.g. `staticmethod`)
-    def _generate_next_value_(self) -> Any: pass
+    def _generate_next_value_(self) -> Any:
+        pass
 
 class IntEnum(int, Enum):
     value: int
     def __new__(cls: Type[_T], value: Union[int, _T]) -> _T: ...
 
-def unique(enumeration: _T) -> _T: pass
+def unique(enumeration: _T) -> _T:
+    pass
 
 # In reality Flag and IntFlag are 3.6 only
 
 class Flag(Enum):
-    def __or__(self: _T, other: Union[int, _T]) -> _T: pass
-
+    def __or__(self: _T, other: Union[int, _T]) -> _T:
+        pass
 
 class IntFlag(int, Flag):
-    def __and__(self: _T, other: Union[int, _T]) -> _T: pass
-
+    def __and__(self: _T, other: Union[int, _T]) -> _T:
+        pass
 
 class auto(IntFlag):
     value: Any
 
-
 # It is python-3.11+ only:
 class StrEnum(str, Enum):
     def __new__(cls: Type[_T], value: str | _T) -> _T: ...
diff --git a/test-data/unit/lib-stub/functools.pyi b/test-data/unit/lib-stub/functools.pyi
index 9e62a14c2..183a36dff 100644
--- a/test-data/unit/lib-stub/functools.pyi
+++ b/test-data/unit/lib-stub/functools.pyi
@@ -8,7 +8,9 @@ class _SingleDispatchCallable(Generic[_T]):
     # @fun.register(complex)
     # def _(arg, verbose=False): ...
     @overload
-    def register(self, cls: type[Any], func: None = ...) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...
+    def register(
+        self, cls: type[Any], func: None = ...
+    ) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...
     # @fun.register
     # def _(arg: int, verbose=False):
     @overload
@@ -20,7 +22,6 @@ class _SingleDispatchCallable(Generic[_T]):
     def __call__(__self, *args: Any, **kwargs: Any) -> _T: ...
 
 def singledispatch(func: Callable[..., _T]) -> _SingleDispatchCallable[_T]: ...
-
 def total_ordering(cls: type[_T]) -> type[_T]: ...
 
 class cached_property(Generic[_T]):
diff --git a/test-data/unit/lib-stub/future/utils.pyi b/test-data/unit/lib-stub/future/utils.pyi
index 1f1e4ec7e..4133a7152 100644
--- a/test-data/unit/lib-stub/future/utils.pyi
+++ b/test-data/unit/lib-stub/future/utils.pyi
@@ -1,2 +1,4 @@
 from typing import Type
-def with_metaclass(meta: Type[type], *bases: type) -> type: pass
+
+def with_metaclass(meta: Type[type], *bases: type) -> type:
+    pass
diff --git a/test-data/unit/lib-stub/math.pyi b/test-data/unit/lib-stub/math.pyi
index 587b04a56..2a3980f44 100644
--- a/test-data/unit/lib-stub/math.pyi
+++ b/test-data/unit/lib-stub/math.pyi
@@ -1,4 +1,5 @@
 pi: float
+
 def sqrt(__x: float) -> float: ...
 def sin(__x: float) -> float: ...
 def cos(__x: float) -> float: ...
diff --git a/test-data/unit/lib-stub/mypy_extensions.pyi b/test-data/unit/lib-stub/mypy_extensions.pyi
index 56fac31e7..50698b961 100644
--- a/test-data/unit/lib-stub/mypy_extensions.pyi
+++ b/test-data/unit/lib-stub/mypy_extensions.pyi
@@ -1,26 +1,29 @@
 # NOTE: Requires fixtures/dict.pyi
 from typing import (
-    Any, Dict, Type, TypeVar, Optional, Any, Generic, Mapping, NoReturn as NoReturn, Iterator,
-    Union, Protocol
+    Any,
+    Dict,
+    Type,
+    TypeVar,
+    Optional,
+    Any,
+    Generic,
+    Mapping,
+    NoReturn as NoReturn,
+    Iterator,
+    Union,
+    Protocol,
 )
 
-_T = TypeVar('_T')
-_U = TypeVar('_U')
-
+_T = TypeVar("_T")
+_U = TypeVar("_U")
 
 def Arg(type: _T = ..., name: Optional[str] = ...) -> _T: ...
-
 def DefaultArg(type: _T = ..., name: Optional[str] = ...) -> _T: ...
-
 def NamedArg(type: _T = ..., name: Optional[str] = ...) -> _T: ...
-
 def DefaultNamedArg(type: _T = ..., name: Optional[str] = ...) -> _T: ...
-
 def VarArg(type: _T = ...) -> _T: ...
-
 def KwArg(type: _T = ...) -> _T: ...
 
-
 # Fallback type for all typed dicts (does not exist at runtime).
 class _TypedDict(Mapping[str, object]):
     # Needed to make this class non-abstract. It is explicitly declared abstract in
@@ -48,7 +51,8 @@ mypyc_attr: Any
 class FlexibleAlias(Generic[_T, _U]): ...
 
 class __SupportsInt(Protocol[T_co]):
-    def __int__(self) -> int: pass
+    def __int__(self) -> int:
+        pass
 
 _Int = Union[int, i32, i64]
 
diff --git a/test-data/unit/lib-stub/numbers.pyi b/test-data/unit/lib-stub/numbers.pyi
index fad173c9a..f35778a80 100644
--- a/test-data/unit/lib-stub/numbers.pyi
+++ b/test-data/unit/lib-stub/numbers.pyi
@@ -3,8 +3,17 @@
 # The numbers module isn't properly supported, but we want to test that mypy
 # can tell that it doesn't work as expected.
 
-class Number: pass
-class Complex: pass
-class Real: pass
-class Rational: pass
-class Integral: pass
+class Number:
+    pass
+
+class Complex:
+    pass
+
+class Real:
+    pass
+
+class Rational:
+    pass
+
+class Integral:
+    pass
diff --git a/test-data/unit/lib-stub/six.pyi b/test-data/unit/lib-stub/six.pyi
index 97dbeabf8..b71031177 100644
--- a/test-data/unit/lib-stub/six.pyi
+++ b/test-data/unit/lib-stub/six.pyi
@@ -1,3 +1,7 @@
 from typing import Type, Callable
-def with_metaclass(mcls: Type[type], *args: type) -> type: pass
-def add_metaclass(mcls: Type[type]) -> Callable[[type], type]: pass
+
+def with_metaclass(mcls: Type[type], *args: type) -> type:
+    pass
+
+def add_metaclass(mcls: Type[type]) -> Callable[[type], type]:
+    pass
diff --git a/test-data/unit/lib-stub/sys.pyi b/test-data/unit/lib-stub/sys.pyi
index 3959cb035..77cd5cee6 100644
--- a/test-data/unit/lib-stub/sys.pyi
+++ b/test-data/unit/lib-stub/sys.pyi
@@ -1,2 +1,2 @@
-version_info = (0, 0, 0, '', 0)
-platform = ''
+version_info = (0, 0, 0, "", 0)
+platform = ""
diff --git a/test-data/unit/lib-stub/types.pyi b/test-data/unit/lib-stub/types.pyi
index 012fd8503..3ec1987aa 100644
--- a/test-data/unit/lib-stub/types.pyi
+++ b/test-data/unit/lib-stub/types.pyi
@@ -1,17 +1,18 @@
 from typing import Any, TypeVar
 import sys
 
-_T = TypeVar('_T')
+_T = TypeVar("_T")
 
-def coroutine(func: _T) -> _T: pass
+def coroutine(func: _T) -> _T:
+    pass
 
 class ModuleType:
     __file__: str
-    def __getattr__(self, name: str) -> Any: pass
+    def __getattr__(self, name: str) -> Any:
+        pass
 
 if sys.version_info >= (3, 10):
     class Union:
         def __or__(self, x) -> Union: ...
 
-    class NoneType:
-        ...
+    class NoneType: ...
diff --git a/test-data/unit/lib-stub/typing.pyi b/test-data/unit/lib-stub/typing.pyi
index b35b64a38..3d3911677 100644
--- a/test-data/unit/lib-stub/typing.pyi
+++ b/test-data/unit/lib-stub/typing.pyi
@@ -32,33 +32,43 @@ Unpack = 0
 Self = 0
 TYPE_CHECKING = 0
 
-T = TypeVar('T')
-T_co = TypeVar('T_co', covariant=True)
-U = TypeVar('U')
-V = TypeVar('V')
+T = TypeVar("T")
+T_co = TypeVar("T_co", covariant=True)
+U = TypeVar("U")
+V = TypeVar("V")
 
 class Iterable(Protocol[T_co]):
-    def __iter__(self) -> Iterator[T_co]: pass
+    def __iter__(self) -> Iterator[T_co]:
+        pass
 
 class Iterator(Iterable[T_co], Protocol):
-    def __next__(self) -> T_co: pass
+    def __next__(self) -> T_co:
+        pass
 
 class Generator(Iterator[T], Generic[T, U, V]):
-    def __iter__(self) -> Generator[T, U, V]: pass
+    def __iter__(self) -> Generator[T, U, V]:
+        pass
 
 class Sequence(Iterable[T_co]):
-    def __getitem__(self, n: Any) -> T_co: pass
+    def __getitem__(self, n: Any) -> T_co:
+        pass
 
 # Mapping type is oversimplified intentionally.
 class Mapping(Iterable[T], Generic[T, T_co]):
-    def keys(self) -> Iterable[T]: pass  # Approximate return type
-    def __getitem__(self, key: T) -> T_co: pass
+    def keys(self) -> Iterable[T]:
+        pass  # Approximate return type
+    def __getitem__(self, key: T) -> T_co:
+        pass
 
 class Awaitable(Protocol[T]):
-    def __await__(self) -> Generator[Any, Any, T]: pass
+    def __await__(self) -> Generator[Any, Any, T]:
+        pass
 
-class Coroutine(Awaitable[V], Generic[T, U, V]): pass
+class Coroutine(Awaitable[V], Generic[T, U, V]):
+    pass
 
-def final(meth: T) -> T: pass
+def final(meth: T) -> T:
+    pass
 
-def reveal_type(__obj: T) -> T: pass
+def reveal_type(__obj: T) -> T:
+    pass
diff --git a/test-data/unit/lib-stub/typing_extensions.pyi b/test-data/unit/lib-stub/typing_extensions.pyi
index 216005e3c..ef622b691 100644
--- a/test-data/unit/lib-stub/typing_extensions.pyi
+++ b/test-data/unit/lib-stub/typing_extensions.pyi
@@ -5,22 +5,26 @@ from typing import NewType as NewType, overload as overload
 
 import sys
 
-_T = typing.TypeVar('_T')
+_T = typing.TypeVar("_T")
 
 class _SpecialForm:
     def __getitem__(self, typeargs: Any) -> Any:
         pass
-
     def __call__(self, arg: Any) -> Any:
         pass
 
 NamedTuple = 0
 Protocol: _SpecialForm = ...
-def runtime_checkable(x: _T) -> _T: pass
+
+def runtime_checkable(x: _T) -> _T:
+    pass
+
 runtime = runtime_checkable
 
 Final: _SpecialForm = ...
-def final(x: _T) -> _T: pass
+
+def final(x: _T) -> _T:
+    pass
 
 Literal: _SpecialForm = ...
 
@@ -55,6 +59,7 @@ class _TypedDict(Mapping[str, object]):
     def values(self) -> Iterable[object]: ...
     if sys.version_info < (3, 0):
         def has_key(self, k: str) -> bool: ...
+
     def __delitem__(self, k: NoReturn) -> None: ...
     # Stubtest's tests need the following items:
     __required_keys__: frozenset[str]
@@ -62,8 +67,8 @@ class _TypedDict(Mapping[str, object]):
     __total__: bool
 
 def TypedDict(typename: str, fields: Dict[str, Type[_T]], *, total: Any = ...) -> Type[dict]: ...
-
-def reveal_type(__obj: T) -> T: pass
+def reveal_type(__obj: T) -> T:
+    pass
 
 def dataclass_transform(
     *,
@@ -73,7 +78,6 @@ def dataclass_transform(
     field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = ...,
     **kwargs: Any,
 ) -> Callable[[T], T]: ...
-
 def override(__arg: _T) -> _T: ...
 
 _FutureFeatureFixture = 0
diff --git a/test-data/unit/plugins/arg_kinds.py b/test-data/unit/plugins/arg_kinds.py
index 5392e64c4..819fbe0ea 100644
--- a/test-data/unit/plugins/arg_kinds.py
+++ b/test-data/unit/plugins/arg_kinds.py
@@ -4,15 +4,13 @@ from mypy.types import Type
 
 
 class ArgKindsPlugin(Plugin):
-    def get_function_hook(self, fullname: str
-                          ) -> Optional[Callable[[FunctionContext], Type]]:
-        if 'func' in fullname:
+    def get_function_hook(self, fullname: str) -> Optional[Callable[[FunctionContext], Type]]:
+        if "func" in fullname:
             return extract_arg_kinds_from_function
         return None
 
-    def get_method_hook(self, fullname: str
-                        ) -> Optional[Callable[[MethodContext], Type]]:
-        if 'Class.method' in fullname:
+    def get_method_hook(self, fullname: str) -> Optional[Callable[[MethodContext], Type]]:
+        if "Class.method" in fullname:
             return extract_arg_kinds_from_method
         return None
 
diff --git a/test-data/unit/plugins/arg_names.py b/test-data/unit/plugins/arg_names.py
index 6c1cbb941..56a7e78d4 100644
--- a/test-data/unit/plugins/arg_names.py
+++ b/test-data/unit/plugins/arg_names.py
@@ -5,29 +5,38 @@ from mypy.types import Type
 
 
 class ArgNamesPlugin(Plugin):
-    def get_function_hook(self, fullname: str
-                          ) -> Optional[Callable[[FunctionContext], Type]]:
-        if fullname in {'mod.func', 'mod.func_unfilled', 'mod.func_star_expr',
-                        'mod.ClassInit', 'mod.Outer.NestedClassInit'}:
+    def get_function_hook(self, fullname: str) -> Optional[Callable[[FunctionContext], Type]]:
+        if fullname in {
+            "mod.func",
+            "mod.func_unfilled",
+            "mod.func_star_expr",
+            "mod.ClassInit",
+            "mod.Outer.NestedClassInit",
+        }:
             return extract_classname_and_set_as_return_type_function
         return None
 
-    def get_method_hook(self, fullname: str
-                        ) -> Optional[Callable[[MethodContext], Type]]:
-        if fullname in {'mod.Class.method', 'mod.Class.myclassmethod', 'mod.Class.mystaticmethod',
-                        'mod.ClassUnfilled.method', 'mod.ClassStarExpr.method',
-                        'mod.ClassChild.method', 'mod.ClassChild.myclassmethod'}:
+    def get_method_hook(self, fullname: str) -> Optional[Callable[[MethodContext], Type]]:
+        if fullname in {
+            "mod.Class.method",
+            "mod.Class.myclassmethod",
+            "mod.Class.mystaticmethod",
+            "mod.ClassUnfilled.method",
+            "mod.ClassStarExpr.method",
+            "mod.ClassChild.method",
+            "mod.ClassChild.myclassmethod",
+        }:
             return extract_classname_and_set_as_return_type_method
         return None
 
 
 def extract_classname_and_set_as_return_type_function(ctx: FunctionContext) -> Type:
-    classname = ctx.args[ctx.callee_arg_names.index('classname')][0].value
+    classname = ctx.args[ctx.callee_arg_names.index("classname")][0].value
     return ctx.api.named_generic_type(classname, [])
 
 
 def extract_classname_and_set_as_return_type_method(ctx: MethodContext) -> Type:
-    classname = ctx.args[ctx.callee_arg_names.index('classname')][0].value
+    classname = ctx.args[ctx.callee_arg_names.index("classname")][0].value
     return ctx.api.named_generic_type(classname, [])
 
 
diff --git a/test-data/unit/plugins/attrhook.py b/test-data/unit/plugins/attrhook.py
index c177072aa..afc3dfc4e 100644
--- a/test-data/unit/plugins/attrhook.py
+++ b/test-data/unit/plugins/attrhook.py
@@ -6,7 +6,7 @@ from mypy.types import Type, Instance
 
 class AttrPlugin(Plugin):
     def get_attribute_hook(self, fullname: str) -> Optional[Callable[[AttributeContext], Type]]:
-        if fullname == 'm.Signal.__call__':
+        if fullname == "m.Signal.__call__":
             return signal_call_callback
         return None
 
diff --git a/test-data/unit/plugins/attrhook2.py b/test-data/unit/plugins/attrhook2.py
index cc14341a6..cf0e343c6 100644
--- a/test-data/unit/plugins/attrhook2.py
+++ b/test-data/unit/plugins/attrhook2.py
@@ -6,9 +6,9 @@ from mypy.types import Type, AnyType, TypeOfAny
 
 class AttrPlugin(Plugin):
     def get_attribute_hook(self, fullname: str) -> Optional[Callable[[AttributeContext], Type]]:
-        if fullname == 'm.Magic.magic_field':
+        if fullname == "m.Magic.magic_field":
             return magic_field_callback
-        if fullname == 'm.Magic.nonexistent_field':
+        if fullname == "m.Magic.nonexistent_field":
             return nonexistent_field_callback
         return None
 
diff --git a/test-data/unit/plugins/badreturn2.py b/test-data/unit/plugins/badreturn2.py
index c7e044784..f5de49cf4 100644
--- a/test-data/unit/plugins/badreturn2.py
+++ b/test-data/unit/plugins/badreturn2.py
@@ -1,5 +1,6 @@
 class MyPlugin:
     pass
 
+
 def plugin(version):
     return MyPlugin
diff --git a/test-data/unit/plugins/callable_instance.py b/test-data/unit/plugins/callable_instance.py
index 40e7df418..5dab84f8e 100644
--- a/test-data/unit/plugins/callable_instance.py
+++ b/test-data/unit/plugins/callable_instance.py
@@ -1,23 +1,26 @@
 from mypy.plugin import MethodContext, Plugin
 from mypy.types import Instance, Type
 
+
 class CallableInstancePlugin(Plugin):
     def get_function_hook(self, fullname):
-        assert not fullname.endswith(' of Foo')
+        assert not fullname.endswith(" of Foo")
 
     def get_method_hook(self, fullname):
         # Ensure that all names are fully qualified
-        assert not fullname.endswith(' of Foo')
+        assert not fullname.endswith(" of Foo")
 
-        if fullname == '__main__.Class.__call__':
+        if fullname == "__main__.Class.__call__":
             return my_hook
 
         return None
 
+
 def my_hook(ctx: MethodContext) -> Type:
     if isinstance(ctx.type, Instance) and len(ctx.type.args) == 1:
         return ctx.type.args[0]
     return ctx.default_return_type
 
+
 def plugin(version):
     return CallableInstancePlugin
diff --git a/test-data/unit/plugins/class_attr_hook.py b/test-data/unit/plugins/class_attr_hook.py
index 348e5df0e..3fb801b31 100644
--- a/test-data/unit/plugins/class_attr_hook.py
+++ b/test-data/unit/plugins/class_attr_hook.py
@@ -5,15 +5,16 @@ from mypy.types import Type as MypyType
 
 
 class ClassAttrPlugin(Plugin):
-    def get_class_attribute_hook(self, fullname: str
-                                 ) -> Optional[Callable[[AttributeContext], MypyType]]:
-        if fullname == '__main__.Cls.attr':
+    def get_class_attribute_hook(
+        self, fullname: str
+    ) -> Optional[Callable[[AttributeContext], MypyType]]:
+        if fullname == "__main__.Cls.attr":
             return my_hook
         return None
 
 
 def my_hook(ctx: AttributeContext) -> MypyType:
-    return ctx.api.named_generic_type('builtins.int', [])
+    return ctx.api.named_generic_type("builtins.int", [])
 
 
 def plugin(_version: str):
diff --git a/test-data/unit/plugins/class_callable.py b/test-data/unit/plugins/class_callable.py
index 07f75ec80..6fa0c7b6b 100644
--- a/test-data/unit/plugins/class_callable.py
+++ b/test-data/unit/plugins/class_callable.py
@@ -2,31 +2,37 @@ from mypy.plugin import Plugin
 from mypy.nodes import NameExpr
 from mypy.types import UnionType, NoneType, Instance
 
+
 class AttrPlugin(Plugin):
     def get_function_hook(self, fullname):
-        if fullname.startswith('mod.Attr'):
+        if fullname.startswith("mod.Attr"):
             return attr_hook
         return None
 
+
 def attr_hook(ctx):
     assert isinstance(ctx.default_return_type, Instance)
-    if ctx.default_return_type.type.fullname == 'mod.Attr':
+    if ctx.default_return_type.type.fullname == "mod.Attr":
         attr_base = ctx.default_return_type
     else:
         attr_base = None
     for base in ctx.default_return_type.type.bases:
-        if base.type.fullname == 'mod.Attr':
+        if base.type.fullname == "mod.Attr":
             attr_base = base
             break
     assert attr_base is not None
     last_arg_exprs = ctx.args[-1]
-    if any(isinstance(expr, NameExpr) and expr.name == 'True' for expr in last_arg_exprs):
+    if any(isinstance(expr, NameExpr) and expr.name == "True" for expr in last_arg_exprs):
         return attr_base
     assert len(attr_base.args) == 1
     arg_type = attr_base.args[0]
-    return Instance(attr_base.type, [UnionType([arg_type, NoneType()])],
-                    line=ctx.default_return_type.line,
-                    column=ctx.default_return_type.column)
+    return Instance(
+        attr_base.type,
+        [UnionType([arg_type, NoneType()])],
+        line=ctx.default_return_type.line,
+        column=ctx.default_return_type.column,
+    )
+
 
 def plugin(version):
     return AttrPlugin
diff --git a/test-data/unit/plugins/common_api_incremental.py b/test-data/unit/plugins/common_api_incremental.py
index 2dcd55977..c83a5afd6 100644
--- a/test-data/unit/plugins/common_api_incremental.py
+++ b/test-data/unit/plugins/common_api_incremental.py
@@ -1,19 +1,17 @@
 from mypy.plugin import Plugin
-from mypy.nodes import (
-    ClassDef, Block, TypeInfo, SymbolTable, SymbolTableNode, MDEF, GDEF, Var
-)
+from mypy.nodes import ClassDef, Block, TypeInfo, SymbolTable, SymbolTableNode, MDEF, GDEF, Var
 
 
 class DynPlugin(Plugin):
     def get_dynamic_class_hook(self, fullname):
-        if fullname == 'lib.declarative_base':
+        if fullname == "lib.declarative_base":
             return add_info_hook
         return None
 
     def get_base_class_hook(self, fullname: str):
         sym = self.lookup_fully_qualified(fullname)
         if sym and isinstance(sym.node, TypeInfo):
-            if sym.node.metadata.get('magic'):
+            if sym.node.metadata.get("magic"):
                 return add_magic_hook
         return None
 
@@ -24,20 +22,20 @@ def add_info_hook(ctx) -> None:
 
     info = TypeInfo(SymbolTable(), class_def, ctx.api.cur_mod_id)
     class_def.info = info
-    obj = ctx.api.named_type('builtins.object')
+    obj = ctx.api.named_type("builtins.object")
     info.mro = [info, obj.type]
     info.bases = [obj]
     ctx.api.add_symbol_table_node(ctx.name, SymbolTableNode(GDEF, info))
-    info.metadata['magic'] = True
+    info.metadata["magic"] = True
 
 
 def add_magic_hook(ctx) -> None:
     info = ctx.cls.info
-    str_type = ctx.api.named_type_or_none('builtins.str', [])
+    str_type = ctx.api.named_type_or_none("builtins.str", [])
     assert str_type is not None
-    var = Var('__magic__', str_type)
+    var = Var("__magic__", str_type)
     var.info = info
-    info.names['__magic__'] = SymbolTableNode(MDEF, var)
+    info.names["__magic__"] = SymbolTableNode(MDEF, var)
 
 
 def plugin(version):
diff --git a/test-data/unit/plugins/config_data.py b/test-data/unit/plugins/config_data.py
index 059e036d5..cff70fc87 100644
--- a/test-data/unit/plugins/config_data.py
+++ b/test-data/unit/plugins/config_data.py
@@ -8,7 +8,7 @@ from mypy.plugin import Plugin, ReportConfigContext
 
 class ConfigDataPlugin(Plugin):
     def report_config_data(self, ctx: ReportConfigContext) -> Any:
-        path = os.path.join('tmp/test.json')
+        path = os.path.join("tmp/test.json")
         with open(path) as f:
             data = json.load(f)
         return data.get(ctx.id)
diff --git a/test-data/unit/plugins/customentry.py b/test-data/unit/plugins/customentry.py
index b3dacfd4c..a22f2b36d 100644
--- a/test-data/unit/plugins/customentry.py
+++ b/test-data/unit/plugins/customentry.py
@@ -1,14 +1,17 @@
 from mypy.plugin import Plugin
 
+
 class MyPlugin(Plugin):
     def get_function_hook(self, fullname):
-        if fullname == '__main__.f':
+        if fullname == "__main__.f":
             return my_hook
         assert fullname
         return None
 
+
 def my_hook(ctx):
-    return ctx.api.named_generic_type('builtins.int', [])
+    return ctx.api.named_generic_type("builtins.int", [])
+
 
 def register(version):
     return MyPlugin
diff --git a/test-data/unit/plugins/customize_mro.py b/test-data/unit/plugins/customize_mro.py
index 0f2396d98..15d69c9b1 100644
--- a/test-data/unit/plugins/customize_mro.py
+++ b/test-data/unit/plugins/customize_mro.py
@@ -1,10 +1,13 @@
 from mypy.plugin import Plugin
 
+
 class DummyPlugin(Plugin):
     def get_customize_class_mro_hook(self, fullname):
         def analyze(classdef_ctx):
             pass
+
         return analyze
 
+
 def plugin(version):
     return DummyPlugin
diff --git a/test-data/unit/plugins/decimal_to_int.py b/test-data/unit/plugins/decimal_to_int.py
index 94aa33ef6..e52f33115 100644
--- a/test-data/unit/plugins/decimal_to_int.py
+++ b/test-data/unit/plugins/decimal_to_int.py
@@ -7,8 +7,10 @@ class MyPlugin(Plugin):
             return decimal_to_int_hook
         return None
 
+
 def plugin(version):
     return MyPlugin
 
+
 def decimal_to_int_hook(ctx):
-    return ctx.api.named_type('builtins.int', [])
+    return ctx.api.named_type("builtins.int", [])
diff --git a/test-data/unit/plugins/depshook.py b/test-data/unit/plugins/depshook.py
index 76277f3cb..fce0e78c8 100644
--- a/test-data/unit/plugins/depshook.py
+++ b/test-data/unit/plugins/depshook.py
@@ -6,8 +6,8 @@ from mypy.nodes import MypyFile
 
 class DepsPlugin(Plugin):
     def get_additional_deps(self, file: MypyFile) -> List[Tuple[int, str, int]]:
-        if file.fullname == '__main__':
-            return [(10, 'err', -1)]
+        if file.fullname == "__main__":
+            return [(10, "err", -1)]
         return []
 
 
diff --git a/test-data/unit/plugins/dyn_class.py b/test-data/unit/plugins/dyn_class.py
index 54bf377aa..14fd3e093 100644
--- a/test-data/unit/plugins/dyn_class.py
+++ b/test-data/unit/plugins/dyn_class.py
@@ -1,14 +1,13 @@
 from mypy.plugin import Plugin
-from mypy.nodes import (
-    ClassDef, Block, TypeInfo, SymbolTable, SymbolTableNode, GDEF, Var
-)
+from mypy.nodes import ClassDef, Block, TypeInfo, SymbolTable, SymbolTableNode, GDEF, Var
 from mypy.types import Instance
 
 DECL_BASES = set()
 
+
 class DynPlugin(Plugin):
     def get_dynamic_class_hook(self, fullname):
-        if fullname == 'mod.declarative_base':
+        if fullname == "mod.declarative_base":
             return add_info_hook
         return None
 
@@ -17,31 +16,34 @@ class DynPlugin(Plugin):
             return replace_col_hook
         return None
 
+
 def add_info_hook(ctx):
     class_def = ClassDef(ctx.name, Block([]))
     class_def.fullname = ctx.api.qualified_name(ctx.name)
 
     info = TypeInfo(SymbolTable(), class_def, ctx.api.cur_mod_id)
     class_def.info = info
-    obj = ctx.api.named_type('builtins.object')
+    obj = ctx.api.named_type("builtins.object")
     info.mro = [info, obj.type]
     info.bases = [obj]
     ctx.api.add_symbol_table_node(ctx.name, SymbolTableNode(GDEF, info))
     DECL_BASES.add(class_def.fullname)
 
+
 def replace_col_hook(ctx):
     info = ctx.cls.info
     for sym in info.names.values():
         node = sym.node
         if isinstance(node, Var) and isinstance(node.type, Instance):
-            if node.type.type.fullname == 'mod.Column':
-                new_sym = ctx.api.lookup_fully_qualified_or_none('mod.Instr')
+            if node.type.type.fullname == "mod.Column":
+                new_sym = ctx.api.lookup_fully_qualified_or_none("mod.Instr")
                 if new_sym:
                     new_info = new_sym.node
                     assert isinstance(new_info, TypeInfo)
-                    node.type = Instance(new_info, node.type.args,
-                                         node.type.line,
-                                         node.type.column)
+                    node.type = Instance(
+                        new_info, node.type.args, node.type.line, node.type.column
+                    )
+
 
 def plugin(version):
     return DynPlugin
diff --git a/test-data/unit/plugins/dyn_class_from_method.py b/test-data/unit/plugins/dyn_class_from_method.py
index 4c3904907..531cdbcb0 100644
--- a/test-data/unit/plugins/dyn_class_from_method.py
+++ b/test-data/unit/plugins/dyn_class_from_method.py
@@ -1,11 +1,11 @@
-from mypy.nodes import (Block, ClassDef, GDEF, SymbolTable, SymbolTableNode, TypeInfo)
+from mypy.nodes import Block, ClassDef, GDEF, SymbolTable, SymbolTableNode, TypeInfo
 from mypy.plugin import DynamicClassDefContext, Plugin
 from mypy.types import Instance
 
 
 class DynPlugin(Plugin):
     def get_dynamic_class_hook(self, fullname):
-        if 'from_queryset' in fullname:
+        if "from_queryset" in fullname:
             return add_info_hook
         return None
 
@@ -17,8 +17,10 @@ def add_info_hook(ctx: DynamicClassDefContext):
     info = TypeInfo(SymbolTable(), class_def, ctx.api.cur_mod_id)
     class_def.info = info
     queryset_type_fullname = ctx.call.args[0].fullname
-    queryset_info = ctx.api.lookup_fully_qualified_or_none(queryset_type_fullname).node  # type: TypeInfo
-    obj = ctx.api.named_type('builtins.object')
+    queryset_info = ctx.api.lookup_fully_qualified_or_none(
+        queryset_type_fullname
+    ).node  # type: TypeInfo
+    obj = ctx.api.named_type("builtins.object")
     info.mro = [info, queryset_info, obj.type]
     info.bases = [Instance(queryset_info, [])]
     ctx.api.add_symbol_table_node(ctx.name, SymbolTableNode(GDEF, info))
diff --git a/test-data/unit/plugins/fnplugin.py b/test-data/unit/plugins/fnplugin.py
index 684d63434..789e2c1c1 100644
--- a/test-data/unit/plugins/fnplugin.py
+++ b/test-data/unit/plugins/fnplugin.py
@@ -1,14 +1,17 @@
 from mypy.plugin import Plugin
 
+
 class MyPlugin(Plugin):
     def get_function_hook(self, fullname):
-        if fullname == '__main__.f':
+        if fullname == "__main__.f":
             return my_hook
         assert fullname is not None
         return None
 
+
 def my_hook(ctx):
-    return ctx.api.named_generic_type('builtins.int', [])
+    return ctx.api.named_generic_type("builtins.int", [])
+
 
 def plugin(version):
     return MyPlugin
diff --git a/test-data/unit/plugins/fully_qualified_test_hook.py b/test-data/unit/plugins/fully_qualified_test_hook.py
index df42d50be..3bdd9a187 100644
--- a/test-data/unit/plugins/fully_qualified_test_hook.py
+++ b/test-data/unit/plugins/fully_qualified_test_hook.py
@@ -1,16 +1,21 @@
 from mypy.plugin import CallableType, MethodSigContext, Plugin
 
+
 class FullyQualifiedTestPlugin(Plugin):
     def get_method_signature_hook(self, fullname):
         # Ensure that all names are fully qualified
-        if 'FullyQualifiedTest' in fullname:
-            assert fullname.startswith('__main__.') and not ' of ' in fullname, fullname
+        if "FullyQualifiedTest" in fullname:
+            assert fullname.startswith("__main__.") and not " of " in fullname, fullname
             return my_hook
-    
+
         return None
 
+
 def my_hook(ctx: MethodSigContext) -> CallableType:
-    return ctx.default_signature.copy_modified(ret_type=ctx.api.named_generic_type('builtins.int', []))
+    return ctx.default_signature.copy_modified(
+        ret_type=ctx.api.named_generic_type("builtins.int", [])
+    )
+
 
 def plugin(version):
     return FullyQualifiedTestPlugin
diff --git a/test-data/unit/plugins/function_sig_hook.py b/test-data/unit/plugins/function_sig_hook.py
index d83c7df26..8fdcb72b4 100644
--- a/test-data/unit/plugins/function_sig_hook.py
+++ b/test-data/unit/plugins/function_sig_hook.py
@@ -1,26 +1,30 @@
 from mypy.plugin import CallableType, CheckerPluginInterface, FunctionSigContext, Plugin
 from mypy.types import Instance, Type
 
+
 class FunctionSigPlugin(Plugin):
     def get_function_signature_hook(self, fullname):
-        if fullname == '__main__.dynamic_signature':
+        if fullname == "__main__.dynamic_signature":
             return my_hook
         return None
 
+
 def _str_to_int(api: CheckerPluginInterface, typ: Type) -> Type:
     if isinstance(typ, Instance):
-        if typ.type.fullname == 'builtins.str':
-            return api.named_generic_type('builtins.int', [])
+        if typ.type.fullname == "builtins.str":
+            return api.named_generic_type("builtins.int", [])
         elif typ.args:
             return typ.copy_modified(args=[_str_to_int(api, t) for t in typ.args])
 
     return typ
 
+
 def my_hook(ctx: FunctionSigContext) -> CallableType:
     return ctx.default_signature.copy_modified(
         arg_types=[_str_to_int(ctx.api, t) for t in ctx.default_signature.arg_types],
         ret_type=_str_to_int(ctx.api, ctx.default_signature.ret_type),
     )
 
+
 def plugin(version):
     return FunctionSigPlugin
diff --git a/test-data/unit/plugins/method_in_decorator.py b/test-data/unit/plugins/method_in_decorator.py
index 99774dfcc..fb7c5ab48 100644
--- a/test-data/unit/plugins/method_in_decorator.py
+++ b/test-data/unit/plugins/method_in_decorator.py
@@ -5,15 +5,17 @@ from mypy.plugin import MethodContext, Plugin
 
 class MethodDecoratorPlugin(Plugin):
     def get_method_hook(self, fullname: str) -> Optional[Callable[[MethodContext], Type]]:
-        if 'Foo.a' in fullname:
+        if "Foo.a" in fullname:
             return method_decorator_callback
         return None
 
+
 def method_decorator_callback(ctx: MethodContext) -> Type:
     if isinstance(ctx.default_return_type, CallableType):
-        str_type = ctx.api.named_generic_type('builtins.str', [])
+        str_type = ctx.api.named_generic_type("builtins.str", [])
         return ctx.default_return_type.copy_modified(ret_type=str_type)
     return ctx.default_return_type
 
+
 def plugin(version):
     return MethodDecoratorPlugin
diff --git a/test-data/unit/plugins/method_sig_hook.py b/test-data/unit/plugins/method_sig_hook.py
index 25c2842e6..875ebfd1d 100644
--- a/test-data/unit/plugins/method_sig_hook.py
+++ b/test-data/unit/plugins/method_sig_hook.py
@@ -1,30 +1,34 @@
 from mypy.plugin import CallableType, CheckerPluginInterface, MethodSigContext, Plugin
 from mypy.types import Instance, Type
 
+
 class MethodSigPlugin(Plugin):
     def get_method_signature_hook(self, fullname):
         # Ensure that all names are fully qualified
-        assert not fullname.endswith(' of Foo')
+        assert not fullname.endswith(" of Foo")
 
-        if fullname.startswith('__main__.Foo.'):
+        if fullname.startswith("__main__.Foo."):
             return my_hook
 
         return None
 
+
 def _str_to_int(api: CheckerPluginInterface, typ: Type) -> Type:
     if isinstance(typ, Instance):
-        if typ.type.fullname == 'builtins.str':
-            return api.named_generic_type('builtins.int', [])
+        if typ.type.fullname == "builtins.str":
+            return api.named_generic_type("builtins.int", [])
         elif typ.args:
             return typ.copy_modified(args=[_str_to_int(api, t) for t in typ.args])
 
     return typ
 
+
 def my_hook(ctx: MethodSigContext) -> CallableType:
     return ctx.default_signature.copy_modified(
         arg_types=[_str_to_int(ctx.api, t) for t in ctx.default_signature.arg_types],
         ret_type=_str_to_int(ctx.api, ctx.default_signature.ret_type),
     )
 
+
 def plugin(version):
     return MethodSigPlugin
diff --git a/test-data/unit/plugins/named_callable.py b/test-data/unit/plugins/named_callable.py
index e40d181d2..ef8154605 100644
--- a/test-data/unit/plugins/named_callable.py
+++ b/test-data/unit/plugins/named_callable.py
@@ -4,23 +4,24 @@ from mypy.types import CallableType
 
 class MyPlugin(Plugin):
     def get_function_hook(self, fullname):
-        if fullname == 'm.decorator1':
+        if fullname == "m.decorator1":
             return decorator_call_hook
-        if fullname == 'm._decorated':  # This is a dummy name generated by the plugin
+        if fullname == "m._decorated":  # This is a dummy name generated by the plugin
             return decorate_hook
         return None
 
 
 def decorator_call_hook(ctx):
     if isinstance(ctx.default_return_type, CallableType):
-        return ctx.default_return_type.copy_modified(name='m._decorated')
+        return ctx.default_return_type.copy_modified(name="m._decorated")
     return ctx.default_return_type
 
 
 def decorate_hook(ctx):
     if isinstance(ctx.default_return_type, CallableType):
         return ctx.default_return_type.copy_modified(
-            ret_type=ctx.api.named_generic_type('builtins.str', []))
+            ret_type=ctx.api.named_generic_type("builtins.str", [])
+        )
     return ctx.default_return_type
 
 
diff --git a/test-data/unit/plugins/plugin2.py b/test-data/unit/plugins/plugin2.py
index b530a62d2..f9f526ffb 100644
--- a/test-data/unit/plugins/plugin2.py
+++ b/test-data/unit/plugins/plugin2.py
@@ -1,13 +1,16 @@
 from mypy.plugin import Plugin
 
+
 class Plugin2(Plugin):
     def get_function_hook(self, fullname):
-        if fullname in ('__main__.f', '__main__.g'):
+        if fullname in ("__main__.f", "__main__.g"):
             return str_hook
         return None
 
+
 def str_hook(ctx):
-    return ctx.api.named_generic_type('builtins.str', [])
+    return ctx.api.named_generic_type("builtins.str", [])
+
 
 def plugin(version):
     return Plugin2
diff --git a/test-data/unit/plugins/type_anal_hook.py b/test-data/unit/plugins/type_anal_hook.py
index 86d18d8c8..1ab8a4e52 100644
--- a/test-data/unit/plugins/type_anal_hook.py
+++ b/test-data/unit/plugins/type_anal_hook.py
@@ -2,21 +2,23 @@ from typing import Optional, Callable
 
 from mypy.plugin import Plugin, AnalyzeTypeContext
 from mypy.types import Type, TypeList, AnyType, CallableType, TypeOfAny
+
 # The official name changed to NoneType but we have an alias for plugin compat reasons
 # so we'll keep testing that here.
 from mypy.types import NoneTyp
 
+
 class TypeAnalyzePlugin(Plugin):
-    def get_type_analyze_hook(self, fullname: str
-                              ) -> Optional[Callable[[AnalyzeTypeContext], Type]]:
-        if fullname == 'm.Signal':
+    def get_type_analyze_hook(
+        self, fullname: str
+    ) -> Optional[Callable[[AnalyzeTypeContext], Type]]:
+        if fullname == "m.Signal":
             return signal_type_analyze_callback
         return None
 
 
 def signal_type_analyze_callback(ctx: AnalyzeTypeContext) -> Type:
-    if (len(ctx.type.args) != 1
-            or not isinstance(ctx.type.args[0], TypeList)):
+    if len(ctx.type.args) != 1 or not isinstance(ctx.type.args[0], TypeList):
         ctx.api.fail('Invalid "Signal" type (expected "Signal[[t, ...]]")', ctx.context)
         return AnyType(TypeOfAny.from_error)
 
@@ -27,12 +29,10 @@ def signal_type_analyze_callback(ctx: AnalyzeTypeContext) -> Type:
         return AnyType(TypeOfAny.from_error)  # Error generated elsewhere
     arg_types, arg_kinds, arg_names = analyzed
     arg_types = [ctx.api.analyze_type(arg) for arg in arg_types]
-    type_arg = CallableType(arg_types,
-                            arg_kinds,
-                            arg_names,
-                            NoneTyp(),
-                            ctx.api.named_type('builtins.function', []))
-    return ctx.api.named_type('m.Signal', [type_arg])
+    type_arg = CallableType(
+        arg_types, arg_kinds, arg_names, NoneTyp(), ctx.api.named_type("builtins.function", [])
+    )
+    return ctx.api.named_type("m.Signal", [type_arg])
 
 
 def plugin(version):
diff --git a/test-data/unit/plugins/union_method.py b/test-data/unit/plugins/union_method.py
index a7621553f..d68755bed 100644
--- a/test-data/unit/plugins/union_method.py
+++ b/test-data/unit/plugins/union_method.py
@@ -1,25 +1,29 @@
 from mypy.plugin import (
-    CallableType, CheckerPluginInterface, MethodSigContext, MethodContext, Plugin
+    CallableType,
+    CheckerPluginInterface,
+    MethodSigContext,
+    MethodContext,
+    Plugin,
 )
 from mypy.types import Instance, Type
 
 
 class MethodPlugin(Plugin):
     def get_method_signature_hook(self, fullname):
-        if fullname.startswith('__main__.Foo.'):
+        if fullname.startswith("__main__.Foo."):
             return my_meth_sig_hook
         return None
 
     def get_method_hook(self, fullname):
-        if fullname.startswith('__main__.Bar.'):
+        if fullname.startswith("__main__.Bar."):
             return my_meth_hook
         return None
 
 
 def _str_to_int(api: CheckerPluginInterface, typ: Type) -> Type:
     if isinstance(typ, Instance):
-        if typ.type.fullname == 'builtins.str':
-            return api.named_generic_type('builtins.int', [])
+        if typ.type.fullname == "builtins.str":
+            return api.named_generic_type("builtins.int", [])
         elif typ.args:
             return typ.copy_modified(args=[_str_to_int(api, t) for t in typ.args])
     return typ
@@ -27,8 +31,8 @@ def _str_to_int(api: CheckerPluginInterface, typ: Type) -> Type:
 
 def _float_to_int(api: CheckerPluginInterface, typ: Type) -> Type:
     if isinstance(typ, Instance):
-        if typ.type.fullname == 'builtins.float':
-            return api.named_generic_type('builtins.int', [])
+        if typ.type.fullname == "builtins.float":
+            return api.named_generic_type("builtins.int", [])
         elif typ.args:
             return typ.copy_modified(args=[_float_to_int(api, t) for t in typ.args])
     return typ
